
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">

    <!-- Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-171431390-1"></script>
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-SPY7S5B91F"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-171431390-1');
    </script>

    <!-- Base File Includes -->
    
    

    <!-- Includes -->
    
    <!-- Code highlighting
        To Use: <pre><code class="language-python">print('Hello World')</code></pre>
    -->
    <link rel="stylesheet" href="/static/home/packages/highlightjs/dracula.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.4.0/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
    <!-- LaTeX input. Use \(...\) for inline mathematics and $$...$$ or \[...\] for block equations -->
	<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
	<script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>


    <!-- Title -->
    <title>
            DRC
        
    - Learn Rust

    </title>
    <!-- ### Bootstrap Files ### -->
    <!-- Fit device screen size -->
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <!-- Bootstrap CSS -->
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
    <!-- Optional JavaScript -->
    <!-- jQuery first, then Popper.js, then Bootstrap JS -->
    <script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/umd/popper.min.js" integrity="sha384-UO2eT0CpHqdSJQ6hJty5KVphtPhzWj9WO1clHTMGa3JDZwrnQq4sF86dIHNDz0W1" crossorigin="anonymous"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js" integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM" crossorigin="anonymous"></script>
    <!-- ### END BOOTSTRAP FILES ### -->
	
	<!-- Font Awesome 4 -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">

    <!-- Load Custom Bootstrap CSS -->
    <link rel="stylesheet" type="text/css" href="/static/home/bootstrap.css">

    <!-- Favicon -->
    <link rel="shortcut icon" type="image/png" href="/static/home/images/favicon.ico">

    <!-- Hide/Reveal Navbar Upon Scrolling -->
    <script src="/static/home/js/navbar_show.js" async></script>
    <link rel="stylesheet" type="text/css" href="/static/home/css/navbar.css">

    <!-- Javascript to run after the page has loaded -->
    <script src="/static/home/js/on_page_load.js" defer></script>
    
</head>

<!-- Body -->
<body class='bg-light'>
    <!-- Navigation Bar -->
    <header class="nav-down">
        <nav class="navbar py-0 navbar-expand-md navbar-dark bg-dark">
    <!-- Website Brand Icon -->
    <a class="navbar-brand" href="/">DRC</a>
    <!-- Menu Button when screen is small -->
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
        <span class="navbar-toggler-icon"></span>
    </button>

    <!-- Navigation Buttons -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
        <ul class="navbar-nav mr-auto">
            <!-- Home -->
            <li class="nav-item dropdown">
                <!-- Screen Reader -->
                
                <div class="btn-group ">
                    <a class="nav-link btn btn-dark pr-1" href="/">Home</a>
                </div>
            </li>
            <!-- Experience -->
            <li class="nav-item dropdown">
                <!-- Screen Reader -->
                
                <!-- Experience Types -->
                <div class="btn-group ">
                    <a class="nav-link btn btn-dark pr-1" href="/resume/">Experience</a>
                    <button type="button" class="btn btn-dark px-1 dropdown-toggle dropdown-toggle-split" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
                        <span class="sr-only">Toggle Dropdown</span>
                    </button>
                    <div class="dropdown-menu py-0 bg-secondary">
                        <a class="dropdown-item" href="/resume/">&#8226; Resume</a>
                        <a class="dropdown-item text-white" href="/work-experience/">&#8226; Work Experience</a>
                        <!-- <a class="dropdown-item text-white" href="/computer-skills/">&#8226; Computer Skills</a> -->
                    </div>
                </div>
            </li>
 
            <!-- Blog Posts -->
<!--            <li class="nav-item dropdown">
                
                <div class="btn-group ">
                    <a class="nav-link btn btn-dark pr-1" href="/blog/">Blog</a>
                    <button type="button" class="btn btn-dark px-1 dropdown-toggle dropdown-toggle-split" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
                        <span class="sr-only">Toggle Dropdown</span>
                    </button>
                    <div class="dropdown-menu py-0 bg-secondary">
                        <a class="dropdown-item" href="/blog/project/">&#8226; Projects</a>
                        <a class="dropdown-item" href="/blog/tutorial/">&#8226; Tutorials</a>
                        <a class="dropdown-item" href="#">&#8226; Other</a>
                    </div>
                </div>
            </li>
-->        
            <!-- Research -->
            <li class="nav-item dropdown">
                <!-- Screen Reader -->
                
                <!-- Experience Types -->
                <div class="btn-group ">
                    <a class="nav-link btn btn-dark pr-1" href="/research/">Research</a>
                    <button type="button" class="btn btn-dark px-1 dropdown-toggle dropdown-toggle-split" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
                        <span class="sr-only">Toggle Dropdown</span>
                    </button>
                    <div class="dropdown-menu active py-0 bg-secondary">
                        <a class="dropdown-item" href="/research/papers/">&#8226; Papers</a>
                        <a class="dropdown-item" href="/research/projects/">&#8226; Projects</a>
                        <a class="dropdown-item" href="/research/notes/">&#8226; Notes</a>
                    </div>
                </div>
            </li>
            <!-- Learn -->
            <li class="nav-item dropdown">
                
                <div class="btn-group ">
                    <a class="nav-link btn btn-dark pr-1" href="/learn/">Learn</a>
                </div>
            </li>
            <!-- Projects -->
            <li class="nav-item dropdown">
                
                <div class="btn-group ">
                    <a class="nav-link btn btn-dark pr-1" href="/projects/">Projects</a>
                </div>
            </li>
            <!-- Write-Ups -->
            <li class="nav-item dropdown">
                
                <div class="btn-group ">
                    <a class="nav-link btn btn-dark pr-1" href="/writeups/kattis/">Write-Ups</a>
                </div>
            </li>
            <!-- About -->
            <li class="nav-item dropdown">
                <!-- Screen Reader -->
                
                <div class="btn-group ">
                    <a class="nav-link btn btn-dark pr-1" href="/about/">About</a>
                </div>
            </li>
            <!-- Contact -->
            <li class="nav-item dropdown">
                <!-- Screen Reader -->
                
                <div class="btn-group ">
                    <a class="nav-link btn btn-dark pr-1" href="/contact/">Contact</a>
                </div>
            </li>
        </ul>
        <!-- Search  bar -->
        <form class="form-inline my-1" action="/search/">
            <input class="form-control mr-0" style="font-size:14px; width:85%;" type="search" placeholder="Search" aria-label="Search" name="q" autocomplete="on">
            <button type="submit" style="width:15%; background-color: Transparent; border-color: Transparent;">
                <i class="fa fa-search" style="font-size:18px; color:#FFFFFF;"></i>
            </button>
        </form>
    </div>
</nav>

    </header>

    <!-- Content -->
    <div style="margin-top:60px;">
        <div class="container rounded m-4 mx-auto p-4 bg-white shadow-lg">
            
<div class="row">
    <!-- Scroll Bar -->
    <div class="d-none d-xl-block col-xl-2 overflow-auto" style="position:relative; overflow-y:scroll; height:80vh">
        <div id="side-navbar" class="list-group flex-xl-column flex-row">
            <center>
                <a class="list-group-item list-group-item-action" href="#rust">
                    Rust
                </a>
            </center>
            
                <a class="list-group-item list-group-item-action" href="#async">
                    Async
                </a>
            
                <a class="list-group-item list-group-item-action" href="#attributes">
                    Attributes
                </a>
            
                <a class="list-group-item list-group-item-action" href="#cargo">
                    Cargo
                </a>
            
                <a class="list-group-item list-group-item-action" href="#closures">
                    Closures
                </a>
            
                <a class="list-group-item list-group-item-action" href="#collections">
                    Collections
                </a>
            
                <a class="list-group-item list-group-item-action" href="#concurrency">
                    Concurrency
                </a>
            
                <a class="list-group-item list-group-item-action" href="#crates">
                    Crates
                </a>
            
                <a class="list-group-item list-group-item-action" href="#debug">
                    Debug
                </a>
            
                <a class="list-group-item list-group-item-action" href="#dyn">
                    Dyn
                </a>
            
                <a class="list-group-item list-group-item-action" href="#enumerations">
                    Enumerations
                </a>
            
                <a class="list-group-item list-group-item-action" href="#error-handling">
                    Error Handling
                </a>
            
                <a class="list-group-item list-group-item-action" href="#expressions">
                    Expressions
                </a>
            
                <a class="list-group-item list-group-item-action" href="#functions">
                    Functions
                </a>
            
                <a class="list-group-item list-group-item-action" href="#generics">
                    Generics
                </a>
            
                <a class="list-group-item list-group-item-action" href="#iterators">
                    Iterators
                </a>
            
                <a class="list-group-item list-group-item-action" href="#lifetimes">
                    Lifetimes
                </a>
            
                <a class="list-group-item list-group-item-action" href="#macros">
                    Macros
                </a>
            
                <a class="list-group-item list-group-item-action" href="#operator-overloading">
                    Operator Overloading
                </a>
            
                <a class="list-group-item list-group-item-action" href="#ownership">
                    Ownership
                </a>
            
                <a class="list-group-item list-group-item-action" href="#rustc">
                    Rustc
                </a>
            
                <a class="list-group-item list-group-item-action" href="#smart-pointers">
                    Smart Pointers
                </a>
            
                <a class="list-group-item list-group-item-action" href="#standard-library">
                    Standard Library
                </a>
            
                <a class="list-group-item list-group-item-action" href="#structs">
                    Structs
                </a>
            
                <a class="list-group-item list-group-item-action" href="#tests">
                    Tests
                </a>
            
                <a class="list-group-item list-group-item-action" href="#traits">
                    Traits
                </a>
            
                <a class="list-group-item list-group-item-action" href="#types">
                    Types
                </a>
            
                <a class="list-group-item list-group-item-action" href="#unsafe">
                    Unsafe
                </a>
            
        </div>
    </div>
    <!-- Content -->
    <div class="col" data-spy="scroll" data-target="#side-navbar" class="scrollspy" style="position:relative; overflow-y:scroll; height:80vh">
        <!-- Theme Information -->
        <h1 id='rust' class='text-center'>Rust</h1>
        <p>The <a href="https://www.rust-lang.org/" target="_blank">Rust</a> programming language is a modern compiled programming language similar to C/C++.</p>

<p>The best way to learn Rust from scratch is via the <a href="https://doc.rust-lang.org/book/title-page.html" target="_blank">book</a>!</p>

        <!-- For each subject -->
        
            <!-- Subject header -->
            <h2 id="async">
                <a href="/learn/rust/async">Async</a>
            </h2>
            
            <!-- For each topic -->
            
        
            <!-- Subject header -->
            <h2 id="attributes">
                <a href="/learn/rust/attributes">Attributes</a>
            </h2>
            
            <!-- For each topic -->
            
        
            <!-- Subject header -->
            <h2 id="cargo">
                <a href="/learn/rust/cargo">Cargo</a>
            </h2>
            <p>Cargo is Rust's build system and package manager.</p>

<p>Publicly available crates can be found at <a href="https://crates.io/" target="_blank">crates.io</a>!</p>

            <!-- For each topic -->
            
                <!-- Topic header -->
                <h4 id="cargo-build">&bull; Build</h4>
                <!-- Include topic -->
                <p><code>$ cargo build</code> compiles your code in <code>./srs</code> and saves the results to <code>./target/debug</code> by default. This command also creates a <code>Cargo.lock</code> file in the base directory. This file is used to keep track of the exact versions of dependencies in the project.</p>

<p>Flags:</p>
<ul>
    <li><code>--release</code>: Compiles the source code with optimizations. Saves the results to <code>target/release</code></li>
</ul>

            
                <!-- Topic header -->
                <h4 id="cargo-check">&bull; Check</h4>
                <!-- Include topic -->
                <p><code>$ cargo check</code> makes sure your project contains valid Rust code (parses the code and checks for syntax errors).</p>

            
                <!-- Topic header -->
                <h4 id="cargo-clippy">&bull; Clippy</h4>
                <!-- Include topic -->
                <p><a href="https://github.com/rust-lang/rust-clippy" target="_blank">Clippy</a> is a linter for Rust code. Use <code>$ cargo clippy</code> to lint your code. Use <code>$ rustup component add clippy</code> to install Clippy first.</p>

            
                <!-- Topic header -->
                <h4 id="cargo-doc">&bull; Doc</h4>
                <!-- Include topic -->
                <p>Rust comes with documentation comments. To use documentation comments, start a line with <code>///</code>. These comments support markdown notation and can be converted to HTML using <a href="https://doc.rust-lang.org/cargo/commands/cargo-doc.html" target="_blank"><code>cargo doc</code></a>. The documents will be saved to <code>target/doc</code></p>

<p>The other documentation comment is <code>//!</code>. This type of comment is used to add comments to what it is in (like crates) as opposed to what is after the comment (a function). These are common at the beginning of a file.</p>

<p>Example (in <code>math/src/lib.rs</code>):</p>
<pre><code class="rust">//! # Math
//!
//! `math` is a collection of mathematical functions

/// Squares the given number
///
/// # Examples
///
/// ```
/// let square = math::square(5);
///
/// assert_eq!(25, square);
/// ```
/// ```
/// let square1 = math::square(1);
///
/// asswert_eq!(1, square1);
/// ```
pub fn square(x: i32) -&gt; i32 {
    x * x
}
</code></pre>

<h6>Flags</h6>
<ul>
    <li><code>--open</code>: Build and open the HTML documentation</li>
</ul>

<h6>Sections</h6>
<ul>
    <li><code>Errors</code>: If a <code>Result</code> is returned, what kind of errors might occur and how are they caused</li>
    <li><code>Examples</code>: Example usage</li>
    <li><code>Panics</code>: What scenarios causes the function to panic</li>
    <li><code>Safety</code>: If <code>unsafe</code> is used, explain why and the variants the caller must uphold</li>
</ul>

<h6>Tests</h6>
<p><code>cargo test</code> actually tests the code left in documentation comments!</p>

            
                <!-- Topic header -->
                <h4 id="cargo-lock">&bull; Lock</h4>
                <!-- Include topic -->
                <p><code>Cargo.lock</code> is used in conjunction with your dependences in <code>Cargo.toml</code>. The <code>Cargo.lock</code> file locks in the version of your dependences when <code>$ cargo build</code> was first executed with the dependency. With this lock, if a newer minor release or other release for the dependency is added, your project will continue to use the old release.</p>

            
                <!-- Topic header -->
                <h4 id="cargo-new">&bull; New</h4>
                <!-- Include topic -->
                <p>Use <code>$ cargo new &lt;project_name&gt;</code> to create a new Rust project. This command will create a nested directory containing a <code>Cargo.toml</code> file and a <code>srs/</code> directory containing a basic source file. In addition, it will initialize a git repository for the project.</p>

<p>The <code>Cargo.toml</code> file is Cargo's configuration file for packages. In Rust, packages of code are called "crates".</p>

<p>Flags:</p>
<ul>
    <li><code>--lib</code>: Initialize a library (make <code>src/lib.rs</code>)</li>
</ul>

            
                <!-- Topic header -->
                <h4 id="cargo-run">&bull; Run</h4>
                <!-- Include topic -->
                <p><code>$ cargo run</code> both compiles your rust code and runs the resulting executable.</p>

            
                <!-- Topic header -->
                <h4 id="cargo-rustfix">&bull; Rustfix</h4>
                <!-- Include topic -->
                <p>Fix rust code (i.e. compiler warnings) using <code>$ cargo fix</code>.</p>

            
                <!-- Topic header -->
                <h4 id="cargo-rustfmt">&bull; Rustfmt</h4>
                <!-- Include topic -->
                <p>You can automatically format rust code using <code>$ cargo fmt</code>. You will first need to install <code>rustfmt</code> using <code>$ rustup component add rustfmt</code>.</p>

            
                <!-- Topic header -->
                <h4 id="cargo-tests">&bull; Tests</h4>
                <!-- Include topic -->
                <p>Cargo has a tests suit. To run, use <code>cargo test</code>. 

<p><code>cargo test</code> accepts two types of parameters separated by <code>--</code>. The flags that go before the <code>--</code> are for <code>cargo test</code> while the flags that go after <code>--</code> are for your test suit. For help you can either do <code>cargo test --help</code> for help with <code>cargo test</code> or <code>cargo test -- --help</code> for help with what you can pass to your test suit.</p>

<h6>Parallel Tests</h6>
<p>By default, tests run in parallel, so it can be dangerous if they use the same resources, like an opened file. To make them run in sequential order, use <code>cargo test -- --test-threads=1</code>.</p>

<h6>Show Output</h6>
<p>By default, output to stdout from your code for tests will not be shown. To show test output do <code>cargo test -- --show</code>.</p>

<h6>Running a Subset of Tests</h6>
<p>To run a subset of the test suit, use <code>cargo test &lt;function name match&gt;</code> where cargo will run any tests that have your inputted string in the test function name.</p>

<h6>Ignore Tests</h6>
<p>To ignore some tests add <code>#[ignore]</code> before the test function but after <code>#[test]</code>. These tests will be ignored unless you do <code>cargo test -- --ignored</code>.</p>

            
                <!-- Topic header -->
                <h4 id="cargo-toml">&bull; Toml</h4>
                <!-- Include topic -->
                <p><code>Cargo.toml</code> is Cargo's configuration file for packages. It contains several sections.</p>

<h6>Dependencies</h6>
<p>The dependencies section (<code>[dependencies]</code>) contains the dependencies for the package. For example:</p>

<pre class="rounded"><code class="toml">[dependencies]
rand = "0.8.3"</code></pre>

<p>This will import the <code>rand</code> external crate with the version number of <code>0.8.X</code> where "X" is 3 or greater. The last number if considered a minor release. Any release with the same first and secondary number will have the same public API and will be compatible.</p>

<h6>Profiles</h6>
<p><a href="https://doc.rust-lang.org/cargo/reference/profiles.html" target="_blank">Profiles</a> allows you to customize how your code is compiled during development and release times. Example:</p>
<pre><code class="toml">[profile.dev]
opt-level = 0
</code></pre>

            
                <!-- Topic header -->
                <h4 id="cargo-update">&bull; Update</h4>
                <!-- Include topic -->
                <p><code>$ cargo update</code> is used to update the crates in the <code>Cargo.lock</code> file. It uses the dependencies found in the <code>Cargo.toml</code> file and updates the <code>Cargo.lock</code> file to the newest appropriate dependency.</p>

            
        
            <!-- Subject header -->
            <h2 id="closures">
                <a href="/learn/rust/closures">Closures</a>
            </h2>
            <p>Closures are similar to functions except they can be stored in a variable and can capture the surrounding variables.</p>

<p>Example:</p>
<pre class="rounded"><code class="rust">fn main() {
    // Normal Closure
    let add_one = |x| {
        x + 1
    };

    // Closures are of a single concrete type
    let y = add_one(1); // The type x is deduced to be an i32
    //let y = add_one(1.0); // Does not compile because x should be an i32, not f32

    // Type information optional
    let verbose_add_one = |x: i32| -&gt; i32 {
        x + 1
    };

    // {} optional if single expression
    let one_linner = |x| x + 1;
    let z = one_linner(2);
}
</code></pre>

            <!-- For each topic -->
            
                <!-- Topic header -->
                <h4 id="closures-returning-closures">&bull; Returning Closures</h4>
                <!-- Include topic -->
                <p>Closures can be returned from functions via a pointer.</p>

<pre><code class="rust">fn returns_closure() -&gt; Box&lt;dyn Fn(u32) -&gt; u32&gt; {
    Box::new(|x| x * x)
}
</code></pre>

            
                <!-- Topic header -->
                <h4 id="closures-traits">&bull; Traits</h4>
                <!-- Include topic -->
                <p>Closures can implement some or all of three traits:</p>
<ul>
    <li><code>Fn</code>: Borrows the values from the environment immutably</li>
    <li><code>FnMut</code>: Mutably borrow values</li>
    <li><code>FnOnce</code>: Consumes the variables it captures from its environment. This closure can be called only once because it consumes the variables.</li>
</ul>

<h6>Fn</h6>
<pre><code class="rust">struct Cacher&lt;T&gt;
where
    T: Fn(i32) -&gt; i32,
{
    func: T,
    value: Option&lt;i32&gt;,
}

impl&lt;T&gt; Cacher&lt;T&gt;
where
    T: Fn(i32) -&gt; i32,
{
    fn new(func: T) -&gt; Cacher&lt;T&gt; {
        Cacher{
            func,
            value: None,
        }
    }

    fn value(&amp;mut self, arg: i32) -&gt; i32 {
        match self.value {
            Some(v) =&gt; v,
            None =&gt; {
                let v = (self.func)(arg);
                self.value = Some(v);
                v
            }
        }
    }
}

fn main() {
    let add = 5;
    let mut saved_value = Cacher::new(|x| x + add);
    println!(&quot;{}&quot;, saved_value.value(2));   // 7
    println!(&quot;{}&quot;, saved_value.value(738)); // 7, because cached
}
</code></pre>

            
        
            <!-- Subject header -->
            <h2 id="collections">
                <a href="/learn/rust/collections">Collections</a>
            </h2>
            
            <!-- For each topic -->
            
                <!-- Topic header -->
                <h4 id="collections-hashmaps">&bull; Hashmaps</h4>
                <!-- Include topic -->
                <p>HashMaps are like unordered maps in C++. <a href="https://doc.rust-lang.org/std/collections/struct.HashMap.html" target="_blank">Docs.</a></p>

<pre class="rounded"><code class="rust">use std::collections::HashMap;

fn main() {
    let mut occur = HashMap::new();

    // All keys must be of the same type and all values must be of the same type
    occur.insert(String::from("Blue"), 12);
    occur.insert(String::from("Red"), 5);

    let teams = vec![String::from("Blue"), String::from("Pink")];
    let scores = vec![5, 78];

    let mut scores: HashMap<_, _> =
        teams.into_iter().zip(scores.into_iter()).collect();
        // Teams and scores becoming iterators. Zip combines them into _, _ iterator
        // Collect transforms the iterator into a container, in this case, a HashMap

    // Hash maps copy for copy traited types, moved for others
    let key = String::from("Moved Key");
    let value = String::from("Moved Value");

    let mut map = HashMap::new();
    map.insert(key, value); // key and value are now invalid identifiers

    // --- Accessing Elements --- //
    let blue_score = scores.get("Blue");  // Wrapped in Some -> Some(&7)

    let team_name = String::from("Pink");
    let pink_score = scores.get(&team_name);  // Some(&78)

    for (key, value) in &scores {
        println!("{}: {}", key, value);
    }

    // --- Updating --- //
    // Overwriting
    scores.insert(String::from("Blue"), 12);
    // Update if key does not exist
    scores.entry(String::from("Purple")).or_insert(42);
    // Update an existing value
    let mut map = HashMap::new();
    let text = "apples pies are full of pies";
    for word in text.split_whitespace() {
        let count = map.entry(word).or_insert(0);  // count is a mutable reference
        *count += 1
    }
    println!("{:?}", map); // HashMaps do NOT retain order

}
</code></pre>

            
                <!-- Topic header -->
                <h4 id="collections-string">&bull; String</h4>
                <!-- Include topic -->
                <p>Strings are encoded as UTF-8 characters in Rust, thus they are a bit weird. They cannot be indexed into since UTF-8 is variable lengthen. <a href="https://doc.rust-lang.org/std/string/struct.String.html" target="_blank">Docs.</a></p>

<pre class="rounded"><code class="rust">fn main() {
    // Initialize
    let mut s = String::new();
    let const_str = "str, not String";
    s = const_str.to_string();
    let mut s = String::from("hello");
    let s2 = String::from(" This is Daltie!");

    // Append
    s.push_str(" world");
    s.push('!');
    let s3 = s + &s2; // s has been moved and can no longer be used
    let s1 = String::from("Hello World!");
    let s3 = format!("{} {}", s1, s2);

    // Iterating Over
    for c in s3.chars() {
        println!("{}" ,c);
    }
}
</code></pre>

            
                <!-- Topic header -->
                <h4 id="collections-vector">&bull; Vector</h4>
                <!-- Include topic -->
                <p>Just like a C++ vector. <a href="https://doc.rust-lang.org/std/vec/struct.Vec.html" target="_blank">Docs.</a></p>

<pre class="rounded"><code class="rust">fn main() {
    // With type annotation
    let _v: Vec<i32> = Vec::new();
    // With type deduction (vec! macro)
    let mut v = vec![1, 2, 3];
    for i in 5..8 {
        v.push(i);
        
    }

    // --- Read element --- //
    // & [index], causes a panic if accessing memory outside of vector
    let _third: &i32 = &v[2];
    let fourth = &v[3];
    let _fourth_copy = v[3]; // Copy of the fourth element
    println!("Forth: {}", fourth);
    // .get() returns Option<&T>
    match v.get(4) {
        Some(fifth) => println!("The fifth element is: {}", fifth),
        None => println!("There is no fifth element!"),
    }

    // -- Iterating -- //
    for i in &v {
        println!("{}", i);
    }
    // Mutable
    for i in &mut v {
        *i += 1; // Dereference operator required to update

    }

    // --- Multi-Type Vector Hack --- //
    enum Colors {
        Rgb(i32),
        Grayscale(f32),
    }
    let _pixels = vec![
        Colors::Rgb(255),
        Colors::Grayscale(3.5),
    ];

    // --- Useful Methods --- //
    // Length
    let _len = v.len();
    // Clear
    v.clear();
    // Insert
    v.insert(0, 4); // Index, value
    // Remove
    let _value = v.remove(0); // Index
    // Push/Pop back
    v.push(5);
    let _value = v.pop();
}
</code></pre>

            
        
            <!-- Subject header -->
            <h2 id="concurrency">
                <a href="/learn/rust/concurrency">Concurrency</a>
            </h2>
            <p>One of the goals of Rust is to make concurrency as safe as can be.</p>

<p>Example:</p>

<pre><code class="rust">use std::sync::mpsc; // Multiple producer, single consumer (mpsc)
use std::sync::{Arc, Mutex};
use std::thread;
use std::time::Duration;

fn main() {
    // Transmitter and Receiver
    let (tx, rx) = mpsc::channel();

    // Mutex must be stored an atomic shared pointer to share between threads
    let counter = Arc::new(Mutex::new(0));

    // Threads list
    let mut handles = vec![];

    for i in 0..=10 {
        let tx2 = tx.clone();
        let counter = Arc::clone(&amp;counter);

        let handle = thread::spawn(move || {
            // Sleep for 1 millisecond
            thread::sleep(Duration::from_millis(100));

            // Will release the lock at the end of the scope
            let mut num = counter.lock().unwrap();
            *num += 1;

            // Transmit string to reciever
            tx2.send(format!(&quot;Thread number: {}, Mut number: {}&quot;, i, num)).unwrap();
        });
        handles.push(handle);
    }

    // Received will end when all tx go out of scope
    // tx acts like a shared pointer, keeping track of references
    drop(tx);
    for received in rx {
        println!(&quot;{}&quot;, received);
    }

    // Wait for threads to stop
    for handle in handles {
        handle.join().unwrap();
    }

    println!(&quot;DONE!&quot;);
}
</code></pre>

            <!-- For each topic -->
            
                <!-- Topic header -->
                <h4 id="concurrency-channel">&bull; Channel</h4>
                <!-- Include topic -->
                <p>Channels allow threads to communicate with one another. A channel consists of a transmitter and a receiver. Given a channel, there can be any number of transmitters but only one receiver.</p>

            
                <!-- Topic header -->
                <h4 id="concurrency-move">&bull; Move</h4>
                <!-- Include topic -->
                <p><code>move</code> allows you to move local variable's ownership to a closure.</p>

<pre><code class="rust">use std::thread;

fn main() {
    let v = vec![0, 1, 2, 3];

    let handle = thread::spawn(move || {
        println!(&quot;{:?}&quot;, v);
    });

    // Cannot use v in main thread anymore

    handle.join().unwrap();
}
</code></pre>

            
                <!-- Topic header -->
                <h4 id="concurrency-mutex">&bull; Mutex</h4>
                <!-- Include topic -->
                <p>Mutexes allows thread safe access to memory. They should be pared with <code>Arc&lt;T&gt;</code> (atomic <code>Rc&lt;T&gt;</code>) to be shared amount threads.</p>

            
                <!-- Topic header -->
                <h4 id="concurrency-traits">&bull; Traits</h4>
                <!-- Include topic -->
                <p>Any type must implment the <code>std::marker</code> traits <code>Sync</code> and <code>Send</code> to be passed into a thread. Any type that does not use non-thread safe pointers automatically implements these traits.</p>

            
        
            <!-- Subject header -->
            <h2 id="crates">
                <a href="/learn/rust/crates">Crates</a>
            </h2>
            
            <!-- For each topic -->
            
                <!-- Topic header -->
                <h4 id="crates-binary">&bull; Binary</h4>
                <!-- Include topic -->
                <p>A package can have any number of binary crates</p>

<p><code>src/main.rs</code> is the default crate root for a binary crate with the same name as the package. To add multiple binary crates, place files in the <code>src/bin/</code> directory. Each file will be a separate binary crate.</p>

            
                <!-- Topic header -->
                <h4 id="crates-library">&bull; Library</h4>
                <!-- Include topic -->
                <p>A package can only have one (or none) library crates.</p>

<p>If a package directory contains <code>src/lib.rs</code>, the package contains a library crate with the same name as the package with <code>src/lib.rs</code> being the crate root. If both <code>src/lib.rs</code> and <code>src/main.rs</code> exist, then the package has two crates</p>

            
                <!-- Topic header -->
                <h4 id="crates-module">&bull; Module</h4>
                <!-- Include topic -->
                <p>Modules are used to organize code within a crate into groups and control the privacy of items (public vs private). The C++ counterpart would be a namespace, except Rust takes it a step further.</p>

<p>Modules are created by using the <code>mod</code> keyword.</p>

<p>The modules in <code>src/main.rs</code> and <code>src/lib.rs</code> are called "crate roots" and is nested under <code>crate</code>.</p>

<p>Modules are private by default (like C++ private methods in a class). To make them public, you have to add the <code>pub</code> keyword. All parents of that module are now public, but children are still private unless specified otherwise.<code>pub</code> can be used on structs, enums, functions, and methods as well.</p>

<p>The keyword <code>super</code> allows you to refer to something in the parent's scope.</p>


<p>Example:</p>
<pre class="rounded"><code class="rust">mod garden {
    // Nest a module inside of another
    pub mod food {
        // Add structs, enums, constants, traits, modules, functions, etc. here
        pub fn harvest() {
            super::soil::amount();
            super::super::plant_garden();
        }
        fn water() {}
    }

    pub mod soil {
        pub fn quality() {}
    
        pub fn amount() { quality(); }
    }
}

pub fn plant_garden() {
    // Relative path
    garden::soil::quality();
    // Absolute path
    crate::garden::soil::amount();
}

fn main() {
    // To access harvest, you'll have to do:
    crate::garden::food::harvest();
    // Both food and harvest must be marked as pub
}
</code></pre>


            
                <!-- Topic header -->
                <h4 id="crates-multiple-files">&bull; Multiple Files</h4>
                <!-- Include topic -->
                <p>Multiple files example:</p>
<pre class="rounded"><code class="rust">// src/garden.rs
pub mod food;

// src/garden/food.rs
pub fn harvest() {}

// src/main.rs
mod garden;

pub use crate::garden::food;

fn main() {
    food::harvest();
}
</code></pre>

            
                <!-- Topic header -->
                <h4 id="crates-package">&bull; Package</h4>
                <!-- Include topic -->
                <p>A package is one or more crates that provide a some functionality. A package contains a <i>Cargo.toml</i> file which describes how to build the crates.</p>

<p>A package can contain as many binary crates as desired but can only contain a maximum of one library crate. A package must contain at least one crate (either library or binary).</p>

            
                <!-- Topic header -->
                <h4 id="crates-paths">&bull; Paths</h4>
                <!-- Include topic -->
                <p>To use a module tree, you'll need the path of the module. The path can be:</p>
<ul>
    <li><code>Absolute path</code>: Starts at the crate root</li>
    <li><code>Relative path</code>: Starts from the current module. Uses <code>self</code>, <code>super</code>, or an identifier in the current module.</li>
</ul>

<p>Which path method used in a module depends on how the module will be used. Absolute paths are generally recommended.</p>

<p><code>::</code> separate each identifier in a path (like C++ namespaces).</p>

            
                <!-- Topic header -->
                <h4 id="crates-public">&bull; Public</h4>
                <!-- Include topic -->
                <p>The keyword <code>pub</code> makes something public, like a function, module, enum, struct etc.</p>

<p>However, structs are special.
<code>pub</code> in front of them just makes them public, not the members inside. The members will not be read nor writable. To make them read/writable, add the <code>pub</code> keyword to the variable itself.</p>

<p>Example:</p>
<pre class="rounded"><code class="rust">mod house {
    pub struct Kitchen {
        pub plates: i32,
        sinks: i8,
    }

    impl Kitchen {
        pub fn duel_sink(num_plates: i32) -> Kitchen {
            Kitchen {
                plates: num_plates,
                sinks: 2,
            }
        }
    }
}

pub fn build_home() {
    let mut home = house::Kitchen::duel_sink(8);
    home.plates += 1;

    // Cannot read nor write to private struct field
    //home.sinks += 1;
    //println!("Num sinks: {}", home.sinks);
}
</code></pre>

            
                <!-- Topic header -->
                <h4 id="crates-use">&bull; Use</h4>
                <!-- Include topic -->
                <p>The keyword <code>use</code> can be used to import code and to shorten absolute/relative paths. It is recommended to import the module and not the specific function so when used, it is obvious that the call is not to a local function. When importing anything other than a function (structs, enums, etc), use the full path.</p>

<p>Example:</p>

<pre class="rounded"><code class="rust">mod garden {
    // Nest a module inside of another
    pub mod food {
        // Add structs, enums, constants, traits, modules, functions, etc. here
        pub fn harvest() {}
        fn water() {}
    }

    pub mod soil {
        pub fn quality() {}
    
        pub fn amount() { quality(); }
    }
}

// Absolute path
use crate::garden::food;
// Relative path
use self::garden::soil;

// Full path for structs
use std::collections::HashMap;


fn main() {
    food::harvest();
    soil::quality();
	let mut map = HashMap::new();
}
</code></pre>

<h6>As</h6>
<p>When there is a name collision with <code>use</code>, the keyword <code>as</code> can be used in conjunction. Example:</p>

<pre class="rounded"><code class="rust">use std::fmt::Result;
use std::io::Result as IoResult;

fn func1() -&gt; Result { // ...  }
fn func2() -&gt; IoResult&lt;()&gt; { // ... }
</code></pre>

<h6>Pub Use</h6>
<p><code>pub use</code> can be used to re-export your code. For example, if you import A into B then import B into C, C would not have access to A because A would be private. If A was imported to B using <code>pub use</code>, then C would have access to A.</p>

<p>Re-exporting is especially useful when creating an API. Inside of <code>src/lib.rs</code>, you can do <code>pub use self::path::to::thing</code> to make others be able to use <code>thing</code> via <code>use my_crate::thing</code> in their code. This allows your API to be more strait-forward than your internal structure.</p>

<h6>Nested Paths</h6>
<p>Example:</p>
<pre class="rounded"><code class="rust">use std::{cmp::Ordering, io}; // Bring in both std::cmp::Ordering and std::io
use std::io::{self, Write}; // std::io and std::io::Write</code></pre>

<h6>Glob</h6>
<p>Brings in all public items from a path into scope. Example:</p>
<pre class="rounded"><code class="rust">use std::collections::*;</code></pre>



            
                <!-- Topic header -->
                <h4 id="crates-workspaces">&bull; Workspaces</h4>
                <!-- Include topic -->
                <p>A workspace is a set of packages that work together. To make a workspace, create a directory with a <code>Cargo.toml</code> file with a <code>[workspace]</code> section. You can then add packages to this workspace via <code>cargo new</code> and adding the name of the crate to the <code>workspace</code> section.</p>

            
        
            <!-- Subject header -->
            <h2 id="debug">
                <a href="/learn/rust/debug">Debug</a>
            </h2>
            
            <!-- For each topic -->
            
                <!-- Topic header -->
                <h4 id="debug-println">&bull; Println</h4>
                <!-- Include topic -->
                <p>The <code>println!</code> macro offers two different ways to print debugging information: <code>{:?}</code> and <code>{:#?}</code>. The <code>{:#?}</code> option is a bit prettier.</p>

<pre class="rounded"><code class="rust">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect = Rectangle {
        width: 25,
        height: 40,
    };

    // {:?}
    println!("rect is {:?}", rect);
    // Output:
    // rect is Rectangle { width: 25, height: 40  }

    // {:#?}
    println!("rect is {:#?}", rect);
    // Output:
    // rect is Rectangle {
    //     width: 25,
    //     height: 40,      
    // }
}</code></pre>

            
        
            <!-- Subject header -->
            <h2 id="dyn">
                <a href="/learn/rust/dyn">Dyn</a>
            </h2>
            <p>The <code>dyn</code> keyword allows Rust to vaguely have the concept of inheritance in the sense that a pointer can dynamically point to more than one type.</p>

<p><code>dyn</code> allows a smart pointer like a <code>Box</code> point to anything that implements a trait.</p>

<p>Rules:</p>
<ul>
    <li>Trait function cannot return <code>self</code> because a concrete <code>self</code> type would not be known at compile time and thus not object safe.</li>
</ul>

            <!-- For each topic -->
            
                <!-- Topic header -->
                <h4 id="dyn-object-oriented-programming">&bull; Object Oriented Programming</h4>
                <!-- Include topic -->
                <p>Rust is not a true OOP language as it does not have inheritance. Rust does allow for a polymorphic like interface via <code>dyn</code> though. Example:</p>

<pre><code class="rust">// Trait for dyn
trait Animal {
    // The use of self instead of &self allows the function to take
    // ownership, and thus invalidating the old state
    fn grow_up(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn Animal&gt;;
    fn age(&amp;self);
}

// Container. Similar to parent class
pub struct DogHouse {
    pub residence: Option&lt;Box&lt;dyn Animal&gt;&gt;
}

impl DogHouse {
    pub fn new() -&gt; DogHouse {
        DogHouse { residence: None }
    }

    pub fn get_puppy(&amp;mut self, s: &amp;str) {
        self.residence = Some(Box::new(Puppy::new(s)));
    }

    pub fn grow_up(&amp;mut self) {
        if let Some(s) = self.residence.take() {
            self.residence = Some(s.grow_up())
        }
    }

    pub fn residence_age(&amp;self) {
        if let Some(s) = &amp;self.residence {
            s.age()
        }
    }
}

pub struct Puppy {}

pub struct Dog {}

impl Puppy {
    pub fn new(name: &amp;str) -&gt; Puppy {
        Puppy{}
    }
}

impl Animal for Puppy {
    fn grow_up(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn Animal&gt; {
        Box::new(Dog {})
    }

    fn age(&amp;self) {
        println!(&quot;Puppy!&quot;);
    }
}

impl Animal for Dog {
    fn grow_up(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn Animal&gt; {
        self
    }

    fn age(&amp;self) {
        println!(&quot;Doggo!&quot;);
    }
}

fn main() {
    let mut red_dog_house = DogHouse::new();
    red_dog_house.get_puppy(&quot;Spike&quot;);
    red_dog_house.residence_age(); // Puppy
    red_dog_house.grow_up();
    red_dog_house.residence_age(); // Doggo
}
</code></pre>

            
        
            <!-- Subject header -->
            <h2 id="enumerations">
                <a href="/learn/rust/enumerations">Enumerations</a>
            </h2>
            <p>Enums are great for categorical data, where something, like an IP address, can belong to one category, such as IPv4 or IPv6. Enums are heavily used in Rust, unlike in C++. Example:</p>

<pre class="rounded"><code class="rust">enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter,
}

// Function that uses an enum as a parameter
fn coin_value(coin: Coin) -&gt; u8 {
    match coin {
        Coin::Penny =&gt; 1,
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        Coin::Quarter =&gt; 25,
    }
}

// Enums can contain data
enum Message {
    Move { x: i32, y: i32 }, // Anonymous struct
    Write(String),
    ChangeColor(i32, i32, i32), // three i32 values
    Quit,
}

// Method of Message
impl Message {
    fn call(&self) {
        // Body
    }
}

fn main() {
    // Use the namespace syntax to choose a category
    let c = Coin::Dime;
    println!("Coin value: {}", coin_value(c));

    let m = Message::Write(String::from("hello"));
    m.call();
}</code></pre>

            <!-- For each topic -->
            
                <!-- Topic header -->
                <h4 id="enumerations-option">&bull; Option</h4>
                <!-- Include topic -->
                <p>Null references have caused lots of problems in other languages. To solve this, Rust created the <code>Option</code> enum. In the <code>Option</code> enum, there are two possibilities: <code>Some</code> (not null) and <code>None</code> (null). The <code>Option</code> enum will not interact with none <code>Option</code> data, thus you have to be aware of when using types that might be null, unlike C++ pointers &#128513;.</p>

<p>This enum is so popular in Rust that it is automatically loaded, <code>Some</code> and <code>None</code> can be used without namespacing them with <code>Option</code>.</p>

<p>The <code>Option</code> enum works well with the <code>match</code> expression, verifying that you cover both the null and not null cases.</p>

<p>Basic definition:</p>
<pre class="rounded"><code class="rust">enum Option&lt;T&gt; {
    Some(T),
    None,
}</code></pre>

<p>Example use:</p>
<pre class="rounded"><code class="rust">// With namespaceing
let some_number = Option::Some(2);
// Without namespacing
let another_number = Some(3);
let some_string = Some("Daltie");

// "Null"
let absent_number: Option&lt;i32&gt; = None; // Need to specify the type that Null would be otherwise

// Options and none options do not interact with each other natively
let x: i8 = 3;
let y: Option&lt;i8&gt; = Some(5);

//let sum = x + y; // Breaks</code></pre>

<p>Function example:</p>
<pre class="rounded"><code class="rust">fn add_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
    match x {
        None =&gt; None,
        Some(i) =&gt; Some(i + 1),
    }
}


fn main() {
    let three = Some(3);
    let four = add_one(three);
    let none = add_one(None);
}
</code></pre>

            
        
            <!-- Subject header -->
            <h2 id="error-handling">
                <a href="/learn/rust/error-handling">Error Handling</a>
            </h2>
            <p>There are two types of errors in rust, recoverable errors and unrecoverable errors.</p>

            <!-- For each topic -->
            
                <!-- Topic header -->
                <h4 id="error-handling-propagating-errors">&bull; Propagating Errors</h4>
                <!-- Include topic -->
                <p>To proprogate and error, return the error.</p>

<h6>The <code>?</code> operator</h6>
<p>The <code>?</code> operator can be used to immediately return an error from a function! The <code>?</code> operator is only valid with functions that return <code>Result</code> or <code>Option</code> (or any type that implements <code>Try</code>). Example:</p>


<pre class="rounded"><code class="rust">use std::fs::File;
use std::io;
use std::io::Read;

fn read_from_file(f_name: &amp;str) -&gt; Result&lt;String, io::Error&gt; {
    let f = File::open(f_name);

    let mut opened_file = match f {
        Ok(file) =&gt; file,
        Err(e) =&gt; return Err(e),
    };

    let mut s = String::new();

    match opened_file.read_to_string(&amp;mut s) {
        Ok(_) =&gt; Ok(s),
        Err(e) =&gt; Err(e),
    }
}

fn shortcut_read_from_file(f_name: &amp;str) -&gt; Result&lt;String, io::Error&gt; {
    let mut f = File::open(f_name)?;  // Return Err if error occurred
    let mut s = String::new();
    f.read_to_string(&amp;mut s)?; // Return Err if error occurred
    Ok(s)
}

fn super_short_read_from_file(f_name: &amp;str) -&gt; Result&lt;String, io::Error&gt; {
    let mut s = String::new();
    File::open(&quot;hello.txt&quot;)?.read_to_string(&amp;mut s)?;
    Ok(s)
}

use std::fs;
fn the_shortest_read_from_file(f_name: &amp;str) -&gt; Result&lt;String, io::Error&gt; {
    fs::read_to_string(f_name)
}

fn main() {
    let f_name = String::from(&quot;file.txt&quot;);
    let s1 = read_from_file(&amp;f_name).unwrap();
    println!(&quot;{}&quot;, s1);
}
</code></pre>

            
                <!-- Topic header -->
                <h4 id="error-handling-recoverable">&bull; Recoverable</h4>
                <!-- Include topic -->
                <p>Rust uses a <code>Result&lt;T, E&gt;</code> enum to catch errors. Functions that have the possibility of erroring returns the <code>Result</code> type. Example:</p>

<pre class="rounded"><code class="rust">use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let f = File::open("file.txt");

    let f = match f {
        Ok(file) => file,  // Return the file
        Err(error) => match error.kind() {
            ErrorKind::NotFound => match File::create("file.txt") {
                Ok(fc) => fc,
                Err(e) => panic!("Cannot create the file: {:?}", e),
            },
            other_error => {
                panic!("Problem opening the file: {:?}", other_error)
            }
        },
    };
}
</code></pre>

<h6>Unwrap</h6>
<p><code>unwrap</code> can be used as a short cut if you want to <code>panic!</code> on error. If an <code>Ok</code> is returned, then <code>unwrap</code> will return the value inside of the <code>OK</code>.</p>

<pre class="rounded"><code class="rust">let f = File::open("file.txt").unwrap();</code></pre>

<h6>Unwrap-Or-Else</h6>
<p>Like <code>unwrap</code> but executes closure if error occured.</p>

<pre class="rounded"><code class="rust">let f = File::open("file.txt").unwrap_or_else(|err| {
    println!("Error: {}", err);
    // Do something else
});</code></pre>

<h6>Expect</h6>
<p>Similar to <code>unwrap</code>, <code>expect</code> can be used to give your own error message in the case of an error.</p>

<pre class="rounded"><code class="rust">let f = File::open("file.txt").expect("Failed to open file.txt");</code></pre>

<h6>Is Error</h6>
<p>Returns true if an error occurred:</p>
<pre><code class="rust">let debug: bool = env::var("DEBUG").is_err();</code></pre>

            
                <!-- Topic header -->
                <h4 id="error-handling-unrecoverable">&bull; Unrecoverable</h4>
                <!-- Include topic -->
                <p><code>panic!</code> is how to raise an unrecoverable error.</p>

<p>By default, when a panic occurs, the program starts unwinding by walking up the stack and cleaning up the data for each function. Alternatively, you can <i>abort</i>, which ends the program without cleaning up. Aborting leads to a smaller binary.</p>

<p>In order to make panics abort instead of unwind in production code (to create smaller binaries), you must add the following to your <code>Cargo.toml</code> file:</p>

<pre class="rounded"><code class="toml">[profile.release]
panic = 'abort'</code></pre>

<h6>Backtrace</h6>
<p>Rust provides backtracing. To use do:</p>
<pre class="rounded"><code class="bash">$ RUST_BACKTRACE=1 cargo run</code></pre>

            
        
            <!-- Subject header -->
            <h2 id="expressions">
                <a href="/learn/rust/expressions">Expressions</a>
            </h2>
            <p>Rust is an expression-based language. Unlike statements: 
<ul>
    <li>Expressions do not end in a semi-colon</li>
    <li>Expressions evaluate to a resulting value (returns something)</li>
</ul>
<p>For example:</p>

<pre class="rounded"><code class="rust">fn main() {
    let x = 1;

    // The {} block is an expression. The entire line is a statement.
    let y = {
        let x = 7; // Different x
        x + 1 // Notice how there is no semi-colon here.
    };

    println!("y = {}", y);
}</code></pre>


            <!-- For each topic -->
            
                <!-- Topic header -->
                <h4 id="expressions-for">&bull; For</h4>
                <!-- Include topic -->
                <p>For loops are used to iterate over collections. Don't worry, a normal C++ for loop is still applicable. You just need to make it more like Python and iterate through some numbers!</p>
<pre class="rounded"><code class="rust">fn main() {
    let arr = [1, 2, 3, 4, 5];

    // Iterate through a collection
    for element in arr.iter() {
        println!("The value is: {}", element);
    }

    // Iterate through a range of values
    for number in 1..6 {
        println!("The value is: {}", number);
    }

    // Iterate through a range, backwards
    for number in (1..6).rev() {
        println!("The value is: {}", number);
    }

    // Inclusive end
    for _ in 1..=9 {}

    // Use vars
    let a = 0;
    let b = 10;
    for i in a..b {
        println!("{}", i)  # println! requires a string literal, not just a variable
    }
}</code></pre>

            
                <!-- Topic header -->
                <h4 id="expressions-if-expression">&bull; If Expression</h4>
                <!-- Include topic -->
                <p>Rust is a standard <code>if</code>, <code>else if</code>, <code>else</code> language, however, only boolean values are allowed for the conditional. Integers will cause a <code>mismatched types</code> error.</p>

<pre class="rounded"><code class="rust">fn main() {
    let number = 12;

    // Standard if, else if, else expression
    if number % 3 == 0 {
        println!("Number is divisible by 3");
    } else if number % 2 == 0 {
        println!("Number is divisible by 2");
    } else {
        println!("Math hard, I gave up.");
    }

    // Using "if" in a let statement (because it's an expression, not a statement)
    let number = if number > 0 { number } else { 0 }; // Return types must match
    println!("number is now: {}", number);
}</code></pre>

<p>If there are many <code>else if</code> expressions, Rust recommends using <code>match</code> instead.</p>

            
                <!-- Topic header -->
                <h4 id="expressions-if-let">&bull; If Let</h4>
                <!-- Include topic -->
                <p>The <code>if let</code> is the little sibling to <code>match</code>. <code>if let</code> allows you to match only one arm of a <code>match</code> expression. The <code>if let</code> expression takes a pattern on the left hand side of an EQUAL SIGN and an expression on the right hand side of an EQUAL SIGN.</p>

<p><code>if let</code> can also be combined with normal <code>if-else</code> statements.</p>

<p>Example:</p>

<pre class="rounded"><code class="rust">#[derive(Debug)]
enum Breed {
    Husky,
    Poodle,
    Lab,
    // Etc.
}

enum Animal {
    Cat,
    Giraffe,
    Dog(Breed), // This Animal::Dog type contains Breed data
}

fn main() {
    // Example A
    let some_i32 = Some(17i32); // Make 17 an i32 type
    if let Some(3) = some_i32 { // Notice the &quot;=&quot; sign
        println!(&quot;Three!&quot;);
    } else {
        println!(&quot;The number was not three :(&quot;);
    }

    // Example B
    let dog = Animal::Dog(Breed::Husky);
    if let Animal::Dog(breed) = dog {
        println!(&quot;We found a {:?} dog!&quot;, breed);
    }
}</code></pre>

            
                <!-- Topic header -->
                <h4 id="expressions-loop">&bull; Loop</h4>
                <!-- Include topic -->
                <p>Rust has three kinds of loops: <code>loop</code>, <code>while</code>, and <code>for</code></p>

<p>There also exists the <code>break</code> statement to break out of a loop and the <code>continue</code> statement to immediately go to the next iteration of the loop.</p>

<p>Values can be returned from loops. For example:</p>
<pre class="rounded"><code class="class">fn main() {
    let mut counter = 0;

    let result = loop {
        counter += 1;

        if counter == 5 {
            break counter * 7;
        }
    };

    println!("result = {}", result);
}</code></pre>

<h6 style="text-align:center">Loop</h6>
<p>The <code>loop</code> loop creates an infinite loop.</p>
<pre class="rounded"><code class="class">fn main() {
    loop {
        println!("Never ending!");
    }
}</code></pre>

            
                <!-- Topic header -->
                <h4 id="expressions-match">&bull; Match</h4>
                <!-- Include topic -->
                <p><code>match</code> is like a switch-case in most other languages. It consists of the <code>match</code> keyword followed by an expression (generally a single variable). In the curly brackets comes the arms. Each arm consists of a pattern and some code. </p>

<p>Matches are exhaustive. Every case for an enum must be handled. <code>match</code> does provide a catch all via the <code>_</code> placeholder.</p>

<p>A <code>|</code> can be used to match multiple patterns.</p>

<p>Each arm of a match expression must return the same type (the "never type" is an exception).</p>

<p>Example:</p>

<pre class="rounded"><code class="rust">#[derive(Debug)]
enum Breed {
    Husky,
    Poodle,
    Lab,
    // Etc.
}

enum Animal {
    Cat,
    Giraffe,
    Dog(Breed), // This Animal::Dog type contains Breed data
    Fox,
    Hamster,
    Snake,
    Daltie,
}

fn sound(animal: Animal) -&gt; String {
    match animal {
        Animal::Cat =&gt; String::from(&quot;Meow&quot;),
        Animal::Giraffe =&gt; String::from(&quot;Hello good Sir&quot;),
        Animal::Dog(breed) =&gt; { // Function like arm block
            println!(&quot;I am a {:?}&quot;, breed);
            String::from(&quot;Woof&quot;)
        },
        Animal::Snake | Animal::Daltie => String::from("I'm a sssnake!"),
        _ =&gt; String::from(&quot;??&quot;), // Catches the Fox and Hamster cases
    }
}

fn main() {
    let husky = Animal::Dog(Breed::Husky);
    println!(&quot;{}&quot;, sound(husky));

    // Match range
    let x = 2;
    
    match x {
        1..=7 =&gt; println!("Small num"),
        _ =&gt; println!("Invalid"),
    }
}</code></pre>


<h6>Destructing</h6>
<p>Structs, enums, tuples, and references can be destructed to their individual parts.</p>

<pre><code class="rust">struct Point{ x: u32, y: u32 }

fn main() {
    let p = Point { x: 0, y: 7 };
    let Point{ x: a, y } = p; // a and y are now valid variables in this scope

    // Match destructured values
    match p {
        Point { x, y: 0 } =&gt; println!(&quot;On the x-axis at {}&quot;, x),
        Point { x: 0, y } =&gt; println!(&quot;On the y-axis at {}&quot;, y),
        Point { x, y } =&gt; println!(&quot;Somewhere, over a rainbow? ({}, {})&quot;, x, y),
    }
}
</code></pre>


<h6>Ignoring Parts</h6>
<pre><code class="rust">struct Point{ x: u32, y: u32 , z: u32}

fn main() {
    let p = Point { x: 0, y: 7, z: 14 };

    // Ignore everything other than y
    match p {
        Point { y, .. } =&gt; println!(&quot;Only care about y: {}&quot;, y), // 7
    }

    let numbers = (1, 2, 3, 4, 5);

    // Only match first and last values
    match numbers {
        (first, .., last) =&gt; println!(&quot;{}, {}&quot;, first, last), // 1, 5
    }
}
</code></pre>

<h6>Match Guards</h6>
<pre><code class="rust">fn main() {
    let num = Some(7);

    match num {
        Some(x) if x &lt; 5 =&gt; println!(&quot;Less than 5&quot;),
        // Match expressions much be exhaustive, so not including
        // this line would cause an complication error
        Some(x) =&gt; println!(&quot;{}&quot;, x),
        None =&gt; (),
    }
}
</code></pre>

<h6>@</h6>
<p><code>@</code> allows you to both test a pattern and bind a variable.</p>

<pre><code class="rust">enum Height {
    Meters { m: u32 },
}

fn main() {
    let tall = Height::Meters{ m: 7 };

    match tall {
        Height::Meters {
            m: meters_var @ 0..=9,
        } =&gt; println!(&quot;You're only {} meters tall! You short!&quot;, meters_var),
        Height::Meters { m: 10..=99 } =&gt; {
            println!(&quot;You fit&quot;) // variable m is not available, need @ if want variable binding
        }
        Height::Meters { m } =&gt; println!(&quot;{} is so tall&quot;, m), // Since there is no testing, m is available
    }
}
</code></pre>

            
                <!-- Topic header -->
                <h4 id="expressions-while">&bull; While</h4>
                <!-- Include topic -->
                <p>Conditional looping!</p>
<pre class="rounded"><code class="rust">fn main() {
    let mut number = 0;

    while number != 5 {
        println!("{}", number);

        number += 1;
    }
}</code></pre>

            
                <!-- Topic header -->
                <h4 id="expressions-while-let">&bull; While Let</h4>
                <!-- Include topic -->
                <p>Similar to <code>if let</code>, <code>while let</code> allows you to loop until the "if let" is false.</p>

<pre><code class="rust">let mut stack = vec![1, 2, 3];

while let Some(top) = stack.pop {
    println!("{}", top);
}
</code></pre>

            
        
            <!-- Subject header -->
            <h2 id="functions">
                <a href="/learn/rust/functions">Functions</a>
            </h2>
            <p>A function in Rust starts with <code>fn</code>. For example:</p>

<pre class="rounded"><code class="rust">fn main() {
    // Body
}</code></pre>

<p><code>main()</code> is the most important function and is where the Rust program starts.</p>

<p>Rust does not care where a function is defined, it just needs to be defined. For example:</p>
<pre class="rounded"><code class="rust">fn main() {
    other_function();
}

fn other_function() {
    println!("This function is declared after main. It could have been declared before main.");
}</code></pre>

            <!-- For each topic -->
            
                <!-- Topic header -->
                <h4 id="functions-function-pointers">&bull; Function Pointers</h4>
                <!-- Include topic -->
                <p>You can pass functions as parameters to functions as well! The <code>fn</code> type is a function pointer.</p>

<p>Function pointers implement all three closure traits <code>Fn</code>, <code>FnMut</code>, and <code>FnOnce</code>).</p>

<pre><code class="rust">fn double(x: u32) -&gt; u32 {
    x * 2
}

fn do_twice(f: fn(u32) -&gt; u32, arg: u32) -&gt; u32 {
    f(arg) * f(arg)
}

fn main() {
    assert_eq!(
        16, 
        do_twice(double, 2)
    )
}
</code></pre>

            
                <!-- Topic header -->
                <h4 id="functions-paramaters">&bull; Paramaters</h4>
                <!-- Include topic -->
                <p>Type annotations for parameters are required in Rust.</p>
<pre class="rouded"><code class="rust">fn main() {
    other_function(12, 'a');
}

fn other_function(x: i32, c: char) {
    println!("The value of x is: {}", x);
    println!("The value of c is: {}", c);
}</code></pre>

            
                <!-- Topic header -->
                <h4 id="functions-return-values">&bull; Return Values</h4>
                <!-- Include topic -->
                <p>Rust requires you to declare a return type for a function if it returns something.</p>
<p>The last line in a function is returned implicitly as long as it is an expression (no semi-colon). A <code>return</code> statement can be used to return prior to the last line.</p>

<pre class="rounded"><code class="rust">fn three() -&gt; i32 {
    3 // Notice the lack of a semi-colon. Expressions return something, statements do not.
}

fn plus_one(x: i32) -&gt; i32 {
    x + 1
}

fn minus_one(x: i32) -&gt; i32 {
    // Because we are explicitly using "return" we can either make this
    // a statement or an expression.
    return x - 1; 
}

fn no_return(x: i32) {
    println!("{}, x");
}

fn main() {
    let x = three();
    println!("x is: {}", x);

    let x = plus_one(x);
    println!("x is now: {}", x);

    let x = minus_one(x);
    println!("x is finally: {}", x);
}
</code></pre>

            
        
            <!-- Subject header -->
            <h2 id="generics">
                <a href="/learn/rust/generics">Generics</a>
            </h2>
            <p>Generics are Rust's version of templates. Examples:</p>

<pre class="rounded"><code class="rust">struct Point&lt;T, U&gt; {
    x: T,
    y: U,
}

impl&lt;T, U&gt; Point&lt;T, U&gt; {
    fn swap&lt;V, W&gt;(self, other: Point&lt;V, W&gt;) -&gt; Point&lt;T, W&gt; {
        Point {
            x: self.x,
            y: other.y,
        }
    }
}

fn main() {
    let p1 = Point { x: 43, y: 3.14 };
    let p2 = Point { x: &quot;Hello&quot;, y: &quot;Daltie&quot; };
    let p3 = p1.swap(p2);
}
</code></pre>

            <!-- For each topic -->
            
        
            <!-- Subject header -->
            <h2 id="iterators">
                <a href="/learn/rust/iterators">Iterators</a>
            </h2>
            <p>Iterators allow you to perform some task on a sequence of items.</p>

<p>Rust iterators are <i>lazy</i>, they do not do anything until a method consumes them.</p>

            <!-- For each topic -->
            
                <!-- Topic header -->
                <h4 id="iterators-collect">&bull; Collect</h4>
                <!-- Include topic -->
                <p>Converts an iterator into a collection. The type of collection must be known. Example:</p>
<pre><code class="rust">let add_one: Vec&lt;_&gt; = vec![1,2,3].iter().map(|x| x + 1).collect();
let add_one_more = add_one.iter().map(|x| x + 1).collect::&lt;Vec&lt;i32&gt;&gt;(); // turbofish type specification
</code></pre>

            
                <!-- Topic header -->
                <h4 id="iterators-filter">&bull; Filter</h4>
                <!-- Include topic -->
                <p>Uses a closure to filter results from an iterator. Only results that return true are added to the resulting iterator.</p>
<pre><code class="rust">let even: Vec&lt;u32&gt; = vec![1,2,3,4].into_iter().filter(|x| x % 2 == 0).collect();
</code></pre>

            
                <!-- Topic header -->
                <h4 id="iterators-iter">&bull; Iter</h4>
                <!-- Include topic -->
                <p>There are three common types of <code>iter</code> functions:</p>
<ul>
    <li><code>iter</code>: Iterator over immutable references</li>
    <li><code>into_iter</code>: Takes ownership of collection and returns owned values</li>
    <li><code>iter_mut</code>: Iterator over mutable references</li>
</ul>

<pre><code class="rust">fn main() {
    let v = vec![1, 2, 3, 4];
    // iter
    let sum: i32 = v.iter().sum(); // 10
    // into_iter
    let even: Vec&lt;i32&gt; = v.into_iter().filter(|x| x % 2 == 0).collect(); // [2, 4]
    // iter_mut
    let mut v = &amp;mut vec![1, 2, 3, 4];
    for x in v.iter_mut() {
        *x += 1;
    } // [2, 3, 4, 5]
}
</code></pre>

            
                <!-- Topic header -->
                <h4 id="iterators-map">&bull; Map</h4>
                <!-- Include topic -->
                <p>Applies a closure to an iterator and returns an iterator. Example:</p>
<pre><code class="rust">let add_one: Vec&lt;_&gt; = vec![1,2,3].iter().map(|x| x + 1).collect();</code></pre>
    

            
                <!-- Topic header -->
                <h4 id="iterators-sum">&bull; Sum</h4>
                <!-- Include topic -->
                <p>Adds together all elements in the collection:</p>
<pre><code class="rust">let total: i32 = vec![1, 2, 3].iter().sum(); // 6</code></pre>

            
                <!-- Topic header -->
                <h4 id="iterators-traits">&bull; Traits</h4>
                <!-- Include topic -->
                <p>All iterators implement a trait named <code>Iterator</code>, which is defined in the standard library. The definition follows:</p>

<pre><code class="rust">pub trait Iterator {
    type Item;
    fn next(&mut self) -> Option&lt;Self::Item&gt;; // Go to next item
}</code></pre>

            
                <!-- Topic header -->
                <h4 id="iterators-zip">&bull; Zip</h4>
                <!-- Include topic -->
                <p>Iterates over two iterators simultaneously.</p>

<pre><code class="rust">let x = vec![1, 2, 3, 4];
    let y = vec![9, 8, 7, 6];

    let z: Vec&lt;i32&gt; = x.iter().zip(y).map(|(a, b)| a + b).collect();

    assert_eq!(z, vec![10, 10, 10, 10]);
</code></pre>

            
        
            <!-- Subject header -->
            <h2 id="lifetimes">
                <a href="/learn/rust/lifetimes">Lifetimes</a>
            </h2>
            <p>A lifetime is how long an object exists, i.e. the scope for which an object's reference is valid. Generally lifetimes are inferred in Rust, but sometimes annotations must be applied so the compile knows how long an object will be around for.</p>

<p>The syntax for explicit lifetimes are: <code>'a</code>, where the 'a' can be any char (well variable string, but who needs more than 26 lifetimes?).</p>

<p>The lifetime annotations live in the same area as templates, and share the same &lt; &gt;.</p>

            <!-- For each topic -->
            
                <!-- Topic header -->
                <h4 id="lifetimes-functions">&bull; Functions</h4>
                <!-- Include topic -->
                <pre class="rounded"><code class="rust">fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}

fn main() {
    let s;
    let x = String::from(&quot;Apple&quot;);
    {
        let y = String::from(&quot;Pie&quot;);
        s = longest(&amp;x, &amp;y);
        println!(&quot;{}&quot;, s);
    }
    // print!(&quot;{}&quot;, s);  // y does not live long enough, therefor s cannot be used here
}
</code></pre>

            
                <!-- Topic header -->
                <h4 id="lifetimes-rules">&bull; Rules</h4>
                <!-- Include topic -->
                <p>Lifetimes have three shortcut rules to make it easier for developers:</p>
<ol>
    <li>Each parameter that is a reference gets its own lifetime</li>
    <ul>
        <li><code>fn foo&lt;'a, 'b&gt;(x: &amp;'a str, y: &amp;'b str)</code></li>
    </ul>
    <li>If there is exactly one input lifetime parameter, that lifetime is applied to all output lifetime parameters</li>
    <ul>
        <li><code>fn foo&lt;'a&gt;(x: &amp;'a str) -&gt; &amp;'a str</code></li>
    </ul>
    <li>If an input lifetime parameter is <code>&self</code> or <code>&mut self</code>, the lifetime of <code>self</code> is automatically to all output lifetime parameters</li>
</ol>

            
                <!-- Topic header -->
                <h4 id="lifetimes-static-lifetimes">&bull; Static Lifetimes</h4>
                <!-- Include topic -->
                <p>Static lifetimes live for the entire duration of the program. They have the <code>'static</code> lifetime annotation.</p>

<pre class="rounded"><code class="rust">fn main() {
    let s;
    {
        let x: &amp;'static str = &quot;LONG LIVE THE STATIC!&quot;;
        s = x;
    }
    println!(&quot;{}&quot;, s); // Static variable is still alive despite leaving scope
}
</code></pre>

            
                <!-- Topic header -->
                <h4 id="lifetimes-structs">&bull; Structs</h4>
                <!-- Include topic -->
                <pre class="rounded"><code class="rust">struct StringWrapper&lt;'a&gt; {
    s: &amp;'a str,
}

impl&lt;'a&gt; StringWrapper&lt;'a&gt; {
    fn print(&amp;self) {
        println!(&quot;{}&quot;, self.s);
    }

    fn get_s(&amp;self) -&gt; &amp;str { // &amp;str does not need a lifetime annotation because of the 3rd shortcut rule
        self.s
    }
}

fn main() {
    let wrapper;
    {
        let sentence = String::from(&quot;Apple Pie&quot;);
        let first_word = sentence.split(' ').next().expect(&quot;Need more than 1 word&quot;); 
        wrapper = StringWrapper {
            s: first_word,
        };
        wrapper.print();
    };
    // wrapper.print();  // first_word, who's lifetime is on sentence, does not live long enough
}
</code></pre>

            
        
            <!-- Subject header -->
            <h2 id="macros">
                <a href="/learn/rust/macros">Macros</a>
            </h2>
            <p>Macros are a form of metaprogramming in Rust. Macros are able to take in a variable number of parameters (like <code>println!</code>) and generate Rust code to satisfy the listed parameters.</p>

            <!-- For each topic -->
            
                <!-- Topic header -->
                <h4 id="macros-eprintln">&bull; Eprintln</h4>
                <!-- Include topic -->
                <p><code>eprintln!</code> does the same thing as <code>println!</code>, but prints to <code>stderr</code> instead.</p>

            
        
            <!-- Subject header -->
            <h2 id="operator-overloading">
                <a href="/learn/rust/operator-overloading">Operator Overloading</a>
            </h2>
            <p>Some operators may be overloaded in rust by implementing the corresponding trait in <code>std::ops</code></p>

            <!-- For each topic -->
            
                <!-- Topic header -->
                <h4 id="operator-overloading-add">&bull; Add</h4>
                <!-- Include topic -->
                <pre><code class="rust">use std::ops::Add;

#[derive(Debug, PartialEq, Copy, Clone)]
struct Point{ x: i32, y: i32 }

impl Add for Point {
    type Output = Point;

    fn add(self, other: Point) -&gt; Point {
        Point {
            x: self.x + other.x,
            y: self.y + other.y,
        }
    }
}

fn main() {
    assert_eq!(
        Point{ x: 3, y: -2 } + Point{ x: 2, y: -3 },
        Point{ x: 5, y: -5 }
    );
}
</code></pre>

            
        
            <!-- Subject header -->
            <h2 id="ownership">
                <a href="/learn/rust/ownership">Ownership</a>
            </h2>
            <p>Ownership is a central part of Rust. Ownership is similar to a unique_ptr in C++, but for all variables, including referenced variables.</p>

<ul>
    <li>Each value has a variable that's called its <i>owner</i></li>
    <li>There can only be one owner at a time</li>
    <li>When the owner goes out of scope, the value will be <i>dropped</i></li>
</ul>

            <!-- For each topic -->
            
                <!-- Topic header -->
                <h4 id="ownership-clone">&bull; Clone</h4>
                <!-- Include topic -->
                <p>To create a deep copy of a variable, using the <code>clone</code> method is required.</p>

<pre class="rounded"><code class="rust">let s1 = String::from("Daltie");
let s2 = s1.clone();

println!("s1 = {}, s2 = {}", s1, s2);</code></pre>

            
                <!-- Topic header -->
                <h4 id="ownership-copy">&bull; Copy</h4>
                <!-- Include topic -->
                <p>The <code>Copy</code> trait copies a variable onto the stack. Scalar types and tuples implement the <code>Copy</code> trait by default.</p>

<h6>Copy VS Drop</h6>
<p>A type may either have a <code>Copy</code> trait or a <code>Drop</code> trait. If a type or any part of a type has implemented the <code>Drop</code> trait then it cannot have the <code>Copy</code> trait. This is to make it very obvious if the type is to be placed on the stack or the heap.</p>

            
                <!-- Topic header -->
                <h4 id="ownership-functions">&bull; Functions</h4>
                <!-- Include topic -->
                <p>Similar to assignment, variables are either moved or copied into a function. Same for return values. For example:</p>

<pre class="rounded"><code class="rust">fn main() {
    let s1 = String::from("Daltie");
    takes_ownership(s1); // s1 is no longer valid

    let x = 3;
    makes_copy(x); // x is still valid

    let s2 = gives_ownership(); // The return value from gives_ownership() is moved

    let s3 = takes_and_gives_ownership(s2); // s2 is no longer valid
} 
// s3 is dropped. 
// s1 and s2 were already moved, so nothing happens. 
// x goes out of scope.

fn takes_ownership(some_str: String) {
    println!("{}", some_str);
}

fn makes_copy(some_int: i32) {
    println!("{}", some_int);
}

fn gives_ownership() -&gt; String {
    let some_str = String::from("Daltie");
    some_str
}

fn takes_and_gives_ownership(some_str: String) -&gt; String {
    some_str
}</code></pre>

            
                <!-- Topic header -->
                <h4 id="ownership-move">&bull; Move</h4>
                <!-- Include topic -->
                <p>In Rust, you need to know what variables will be put on the stack and which variables will be added to the heap. Heap and stack variables are treated differently.</p>

<h6>Stack</h6>
Stack variables consist of basic types with a known size at compile time. Stack variables are valid until they go out of scope. For example:

<pre class="rounded"><code class="rust">let x = 3;
let y = x;</code></pre>

<p>Both <code>x</code> and <code>y</code> are valid and contain the value <code>3</code> until they go out of scope.</p>


<h6>Heap</h6>
<p>Heap variables follow similar but more strict rules to shallow copies in Python in the sense that the new variable will point to the data, however, in Rust, the old variable becomes invalid. For example:</p>

<pre class="rounded"><code class="rust">let s1 = String::from("hello");
let s2 = s1;</code></pre>

<p>Line 1 initializes a String variable by creating a string of size 5(ish) on the heap and a pointer to said string on the stack. Line 2 then takes ownership of this heap string. <code>s1</code> now no longer points to the string and <code>s1</code> is no longer valid and cannot be used until it is re-assigned. The data is NEVER <b>copied</b>, instead it behaves similarly to C++'s move semantics.</p>

<p>See the <a href="https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html#ways-variables-and-data-interact-move" target="_blank">Rust Book</a> for fantastic diagrams of this process, specifically Figure 4-4.</p>

            
                <!-- Topic header -->
                <h4 id="ownership-references">&bull; References</h4>
                <!-- Include topic -->
                <h6>Functions</h6>
<p>Rust lets a function borrow a variable using references.</p>

<pre class="rounded"><code class="rust">fn main() {
    let s1 = String::from("Daltie");
    let len = find_length(&s1);

    println!("The length of '{}' is {}.", s1, len);
}

fn find_length(s: &String) -&gt; usize {
    s.len()
}
// s is never actually given ownership, it is simply borrowing the String,
// thus nothing happens when s goes out of scope</code></pre>

<h6>Mutable References</h6>
<p>Rust allows for exactly one mutable reference per scope (as long as the variable is active).</p>

<pre class="rounded"><code class="rust">fn main() {
    let mut s = String::from("Daltie");

    change(&mut s);

    let r1 = &mut s;
    r1.push_str(" is ");
    println!("{}", r1); // "Daltie Cole is"
    
    let r2 = &mut s; // Okay because r1 is never used after r2 creation
    r2.push_str(" cool!");
    println!("{}", r2); // "Daltie Cole is cool!"

    // Either unlimited immutable references are allowed at once OR one mutable reference is allowed per scope
    let r3 = &s;
    let r4 = &s;
    //let r5 = &mut s; // BREAKS

    println!("{}, {}", r3, r4);
}

fn change(some_str: &mut String) {
    some_str.push_str(" Cole");
}
</code></pre>

            
        
            <!-- Subject header -->
            <h2 id="rustc">
                <a href="/learn/rust/rustc">Rustc</a>
            </h2>
            <p>To compile rust code, you use <code>rustc</code></p>

<p>For example, to compile the file <code>main.rs</code> you would do <code>$ rustc main.rs</code>. This would then create the executable <code>main</code></p>


            <!-- For each topic -->
            
        
            <!-- Subject header -->
            <h2 id="smart-pointers">
                <a href="/learn/rust/smart-pointers">Smart Pointers</a>
            </h2>
            <p>Smart pointers in Rust are like smart pointers in C++. Unlike references which only borrow data, smart pointers can own the data they point to.</p>



            <!-- For each topic -->
            
                <!-- Topic header -->
                <h4 id="smart-pointers-box">&bull; Box</h4>
                <!-- Include topic -->
                <p>A <code>Box&lt;T&gt;</code> stores data on the heap rather than the stack. A pointer to that heap data remains on the stack. They are useful when:</p>
<ul>
    <li>Don't know the size of the type at compile time but will need to know the exact size during run time</li>
    <li>Want to transfer ownership of a large amount of data without copying.</li>
    <li>When you own a value and only care about its implemented traits, not its type (polymorphism)</li>
</ul>

<p>Immutable or mutable borrow checking is done at compile time.</p>

<p>Example:</p>
<pre><code class="rust">pub enum LinkedList {
    Con(i32, Box&lt;LinkedList&gt;),
    Nil,
}


use crate::LinkedList::{Con, Nil};

fn main() {
    let list = Con(1,
        Box::new(Con(2, 
                Box::new(Con(3, Box::new(Nil))))));

    assert_eq!(1, match list {
        Con(value, next) =&gt; value,
        Nil =&gt; -1,
    });
}
</code></pre>

            
                <!-- Topic header -->
                <h4 id="smart-pointers-deref-coercion">&bull; Deref Coercion</h4>
                <!-- Include topic -->
                <p>Deref coercion allows a referenced type to another type, for example, <code>&String</code> can be converted to <code>&str</code> because <code>String</code> implements the <code>Deref</code> trait and returns <code>&str</code>.</p>

<p>The <code>DerefMut</code> trait can be used to override the <code>*</code> operator on mutable references.</p>

<p>In addition, mutable references can be coerced to become immutable if the <code>Deref</code> trait is implemented.</p>

<p>Example:</p>

<pre><code class="rust">use std::ops::Deref;
use std::ops::DerefMut;

struct MyBox&lt;T&gt;(T);

impl&lt;T&gt; MyBox&lt;T&gt; {
    fn new(x: T) -&gt; MyBox&lt;T&gt; {
        MyBox(x)
    }
}

impl&lt;T&gt; Deref for MyBox&lt;T&gt; {
    type Target = T;

    fn deref(&amp;self) -&gt; &amp;Self::Target {
        &amp;self.0
    }
}

impl&lt;T&gt; DerefMut for MyBox&lt;T&gt; {
    fn deref_mut(&amp;mut self) -&gt; &amp;mut Self::Target {
        &amp;mut self.0
    }
}

fn deref_coercion(name: &amp;str) {
    println!(&quot;{}&quot;, name);
}

fn deref_mut_coercion(num: &amp;mut f32) {
    *num += 3.0
}


fn main() {
    let x = MyBox::new(2);
    assert_eq!(2, *x);

    let n = MyBox::new(String::from(&quot;Rust&quot;));
    deref_coercion(&amp;n);
    let mut m = MyBox::new(12.2);
    deref_mut_coercion(&amp;mut m);
}
</code></pre>

            
                <!-- Topic header -->
                <h4 id="smart-pointers-refCell">&bull; Refcell</h4>
                <!-- Include topic -->
                <p><code>RefCell&lt;T&gt;</code> is like <code>Box&lt;T&gt;</code> except the borrow checker is checked at runtime instead of compile time. This allows the programmer to make code that they know will work, but the borrow checker is unsure about.</p>

<p><code>RefCell&lt;T&gt;</code> is only used in single-threaded scenarios.</p>

<p>Both immutable and mutable borrow checking is done at runtime. The value inside of <code>RefCell&lt;T&gt;</code> can be mutated even if <code>RefCell&lt;T&gt;</code> is immutable.</p>

<p>This is useful when you need to mutate something that is passed in as immutable.</p>

            
                <!-- Topic header -->
                <h4 id="smart-pointers-reference-counted">&bull; Reference Counted</h4>
                <!-- Include topic -->
                <p>A reference counted smart pointer is the same as a shared pointer in C++. The <code>Rc&lt;T&gt;</code> pointer keeps track of the number of references to it and frees up memory when the reference count is zero.</p>

<p><code>Rc&lt;T&gt;</code> can only be used for single-threaded scenarios.</p>

<p>Only immutable borrow checking is done at compile time.</p>

<p><b><code>Rc&lt;T&gt;</code> can only hold immutable data. Pair with <code>RefCell&lt;T&gt;</code> for mutability.</b></p>

<pre><code class="rust">use std::cell::RefCell;
use std::rc::Rc;

fn main() {
    let v = Rc::new(RefCell::new(vec![1, 2, 3]));
    let w = Rc::clone(&amp;v);
    let x = Rc::clone(&amp;v);

    // Add 4 to vector
    v.borrow_mut().push(4);

    //would_cause_panic(&amp;v);

    println!(&quot;{:?}&quot;, x);
}

fn would_cause_panic(v: &amp;Rc&lt;RefCell&lt;Vec&lt;u32&gt;&gt;&gt;) {
    let mut one_borrow = v.borrow_mut();
    // Panic because two mutable references
    // During rumtime with RefCell
    let mut two_borrow = v.borrow_mut();
}
</code></pre>

<h6>Strong vs Weak Count</h6>
<p>When <code>strong_count</code> reaches <code>0</code>, the instance is cleaned up. Clean up does not care how many weak references there are. Using <code>Weak&lt;T&gt;</code> is one way to help prevent memory leaks (via circular referencing).</p>

<p>Since what <code>Weak&lt;T&gt;</code> references may have been dropped, it is necessary to call <code>upgrade</code> which returns an <code>Option&lt;RC&lt;T&gt;&gt;</code> to verify that the reference still exists.</p>

<pre><code class="rust">use std::cell::RefCell;
use std::rc::{Rc, Weak};

#[derive(Debug)]
struct Node {
    value: i32,
    parent: RefCell&lt;Weak&lt;Node&gt;&gt;,
    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
}

fn main() {
    let leaf = Rc::new(Node {
        value: 6,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![]),
    });

    println!(&quot;leaf parent = {:#?}&quot;, leaf.parent.borrow().upgrade()); // None

    let branch = Rc::new(Node {
        value: 42,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![Rc::clone(&amp;leaf)]),
    });

    // Downgrade strong to weak
    *leaf.parent.borrow_mut() = Rc::downgrade(&amp;branch);

    println!(&quot;leaf parent = {:#?}&quot;, leaf.parent.borrow().upgrade()); // Some
}
</code></pre>

            
                <!-- Topic header -->
                <h4 id="smart-pointers-traits">&bull; Traits</h4>
                <!-- Include topic -->
                <p>Smart pointers implement the <code>Deref</code> and <code>Drop</code> traits.</p>

            
        
            <!-- Subject header -->
            <h2 id="standard-library">
                <a href="/learn/rust/standard-library">Standard Library</a>
            </h2>
            
            <!-- For each topic -->
            
                <!-- Topic header -->
                <h4 id="standard-library-command-line-arguments">&bull; Command Line Arguments</h4>
                <!-- Include topic -->
                <pre class="rounded"><code class="rust">use std::env;

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect(); // Turn argument iterator into a vector
    println!(&quot;{:?}&quot;, args); // Prints the arguments along with the binary name

    // Convert first argument to i32
    let num: i32 = args[1].parse().unwrap();
}
</code></pre>

            
                <!-- Topic header -->
                <h4 id="standard-library-environmental-variables">&bull; Environmental Variables</h4>
                <!-- Include topic -->
                <pre><code class="rust">use std::env;

fn debug() {
    let DEBUG = env::var("DEBUG").is_err();
}</code></pre>

            
                <!-- Topic header -->
                <h4 id="standard-library-read-file">&bull; Read File</h4>
                <!-- Include topic -->
                <pre class="rounded"><code class="rust">use std::fs;

fn read_file(file_name: &amp;str) -&gt; String {
    fs::read_to_string(file_name)
        .expect(&quot;Failed to open file {}&quot;)
}

fn main() {
    let file_name = &quot;file.txt&quot;;
    read_file(file_name);
}
</code></pre>

            
        
            <!-- Subject header -->
            <h2 id="structs">
                <a href="/learn/rust/structs">Structs</a>
            </h2>
            <p>Structs are essentially tuples with named fields. For example: </p>

<pre class="rounded"><code class="rust">struct User {
    username: String,
    email: String,
    sign_in_count: u64,
    active: bool,
}

fn main() {
    // Normal Declaration
    let user1 = User {
        email: String::from("contact@daltoncole.com"),
        username: String::from("drc"),
        active: true,
        sign_in_count: 1,
    };

    let user2 = build_user_annoying_way(String::from("bob@bob.bob"), String::from("bob"));
    let user3 = build_user_easy_way(String::from("john@bob.com"), String::from("john"));

    // Struct Update (quick way to change only some fields from another instance)
    let user4 = User {
        email: String::from("me@daltoncole.com"),
        username: String::from("crd"),
        ..user1 // Copies the rest of the data from user 1
    };

    println!(
        "The users are: {}, {}, {}, and {}", 
        user1.username, user2.username, user3.username, user4.username
    )
}

fn build_user_annoying_way(email: String, username: String) -&gt; User {
    User {
        email: email,
        username: username,
        active: true,
        sign_in_count: 1,
    }
}

// Since the variable names share the same name as the field,
//   we can just use the variables instead
fn build_user_easy_way(email: String, username: String) -&gt; User {
    User {
        email,
        username,
        active: true,
        sign_in_count: 1,
    }
}</code></pre>

            <!-- For each topic -->
            
                <!-- Topic header -->
                <h4 id="structs-methods">&bull; Methods</h4>
                <!-- Include topic -->
                <p>Struct methods are implemented in <code>impl</code> blocks. Multiple methods can be in a single <code>impl</code> block and you can have multiple <code>impl</code> blocks per struct.</p>

<p>The general syntax of methods are very similar to python methods, where instance methods require <code>&self</code> (just using <code>self</code> is allowed but rare). To call "class" level methods, the namespace operator <code>::</code> is required.</p>

<pre class="rounded"><code class="rust">struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    // Self's type is automatically the struct's type
    fn area(&self) -&gt; u32 {
        self.width * self.height
    }

    fn fits_inside(&self, other: &Rectangle) -&gt; bool {
        self.width > other.width && self.height > other.height
    }
}

impl Rectangle {
    // Example where you wouldn't use self
    fn square(size: u32) -&gt; Rectangle {
        Rectangle {
            width: size,
            height: size,
        }
    }
}

fn main() {
    let rect1 = Rectangle {
        width: 25,
        height: 40,
    };

    let rect2 = Rectangle {
        width: 100,
        height: 45,
    };

    println!("Area of rect1: {}", rect1.area());
    println!("Fits inside: {}", rect1.fits_inside(&rect2));

    // Create a square rectangle. Use the namespace syntax here
    let square = Rectangle::square(7);
    println!("Area of square: {}", square.area());
}</code></pre>

            
                <!-- Topic header -->
                <h4 id="structs-tuple-structs">&bull; Tuple Structs</h4>
                <!-- Include topic -->
                <p>You can also create structs that behave like tuples, i.e. structs without named fields. This can be useful when you want to pass tuples that contain specific information into a function.</p>

<pre class="rounded"><code class="rust">struct Color(i32, i32, i32);
struct Point(i32, i32, i32);

fn main() {
    let white = Color(255, 255, 255);
    let origin = Point(0, 0, 0);

    print_color(white);
    //print_color(origin); // Breaks
}

fn print_color(color: Color) {
    // Use "." followed by the index to index into a Tuple Struct
    println!("({}, {}, {})", color.0, color.1, color.2);
}</code></pre>

            
        
            <!-- Subject header -->
            <h2 id="tests">
                <a href="/learn/rust/tests">Tests</a>
            </h2>
            <p>Rust comes with a unit and integration test suit baked into <code>cargo</code>. To make a function a test function, add <code>#[test]</code> on the line before the function.</p>

<p>Tests in rust have access to the private parts of everything.</p>

<p>The following is an example of a unit test:</p>

<pre class="rounded"><code class="rust">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn new(w: u32, h: u32) -&gt; Rectangle {
        Rectangle {width: w, height: h}
    }

    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
    }
}

#[cfg(test)]
mod tests {
    use super::*;  // Brings outer module into scope
    
    #[test]
    fn larger_can_hold_smaller() {
        let larger = Rectangle::new(5, 6);
        let smaller = Rectangle::new(4, 5);

        assert!(larger.can_hold(&amp;smaller));
    }

    #[test]
    fn smaller_cannot_hold_larget() {
        let smaller = Rectangle::new(4, 5);
        let larger = Rectangle::new(5, 6);

        assert!(!smaller.can_hold(&amp;larger));
    }

    #[test]
    fn it_works() -&gt; Result&lt;(), String&gt; {
        if 2 + 2 == 4 {
            Ok(())
        } else {
            Err(String::from(&quot;2 + 2 != 4&quot;))
        }
    }
}
</code></pre>

            <!-- For each topic -->
            
                <!-- Topic header -->
                <h4 id="tests-asserts">&bull; Asserts</h4>
                <!-- Include topic -->
                <ul>
    <li><code>assert!(x)</code>: Passes if <code>x</code> is true</li>
    <li><code>assert_eq!(x, y)</code>: Passes if <code>x</code> and <code>y</code> are equal</li>
    <li><code>assert_ne!(x, y)</code>: Passes if <code>x</code> and <code>y</code> are not equal</li>
</ul>

            
                <!-- Topic header -->
                <h4 id="tests-custom-failure-messages">&bull; Custom Failure Messages</h4>
                <!-- Include topic -->
                <p>Custom failure messages are supported by the <code>assert</code> family micros.</p>

<pre class="rounded"><code class="rust">pub fn concat(fname: &amp;str, lname: &amp;str) -&gt; String {
    format!(&quot;{} {}&quot;, fname, lname)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn combine_names() {
        let full_name = concat(&quot;Daltie&quot;, &quot;Colti&quot;);
        assert_eq!(
            full_name,
            &quot;Daltie Coltie&quot;,
            &quot;Daltie Coltie != {}&quot;,
            full_name
        ) // The same failure message logic can be applied to any assert! micro
    }
}
</code></pre>

            
                <!-- Topic header -->
                <h4 id="tests-integration-tests">&bull; Integration Tests</h4>
                <!-- Include topic -->
                <p>Integration tests are external to your library. They can only call your library's public API.</p>

<p>Integration tests are only for library crates. For binary crates, only unit tests can be used.</p>

<p>Integration tests go inside of a <i>tests</i> directory next to your <i>src</i> directory. Example:</p>


<pre class="rounded"><code class="rust">// src/lib.rs in crate addr
pub fn add_two(x: i32) -&gt; i32 {
    x + 2
}

// tests/integration_tests.rs
use addr;

#[test]
fn it_adds_two() {
    assert_eq!(4, addr::add_two(2));
}
</code></pre>

<h6>Submodules</h6>
<p>Each file in the <i>tests</i> directory is compiled as its own separate crate. To prevent this, put code you don't want separately tested into subdirectories inside of <i>tests</i>. These subdirectories will not be tested, but can act as support code for your tests.</p>

            
                <!-- Topic header -->
                <h4 id="tests-should-panic">&bull; Should Panic</h4>
                <!-- Include topic -->
                <p>If a test should panic, add <code>#[should_panic]</code> before the function declaration.</p>
<pre class="rounded"><code class="rust">#[test]
#[should_panic]
fn this_should_panic() {
    panic_function(1000);
}
</code></pre>

            
                <!-- Topic header -->
                <h4 id="tests-unit-tests">&bull; Unit Tests</h4>
                <!-- Include topic -->
                <p>Unit tests are used to test how your code interacts with itself, testing one module in isolation at a time.</p>

<h6>Location</h6>
<p>Unit tests live along side your code in the <i>src</i> directory in the same file as the code that it is testing. To create a unit test, create a module called <code>tests</code> with the <code>#[cfg(test)]</code> annotation. "cfg" stands for <i>configuration</i>.</p>

<h6>Privacy</h6>
<p>Unit tests can test the private parts of your code.</p>

            
        
            <!-- Subject header -->
            <h2 id="traits">
                <a href="/learn/rust/traits">Traits</a>
            </h2>
            <p>Traits in Rust are similar to <i>interfaces</i> in other languages. When a type implements a trait, that type will behave as the trait describes. </p>

<pre class="rounded"><code class="rust">pub trait Shape {
    fn area(&amp;self) -&gt; f32;  // Traits declarations have ';' as opposed to {} blocks
}

pub struct Circle {
    radius: f32,
}

impl Shape for Circle {
    fn area(&amp;self) -&gt; f32 {
        self.radius * 3.14159
    }
}

pub struct Rectable {
    width: f32,
    height: f32,
}

impl Shape for Rectable {
    fn area(&amp;self) -&gt; f32 {
        self.width * self.height
    }
}

fn main() {
    let cir = Circle { radius: 12.25 };
    println!(&quot;{}&quot;, cir.area());
}
</code></pre>

            <!-- For each topic -->
            
                <!-- Topic header -->
                <h4 id="traits-associated-types">&bull; Associated Types</h4>
                <!-- Include topic -->
                <p>Associated types act as a type placeholder for traits in method signatures. When the trait is implemented, the associated type is replaced with the concrete type.</p>

<pre><code class="rust">struct Point {x: i32, y: i32}

trait Contains {
    // Declare placeholder types
    type A;
    type B;

    fn contains(&amp;self, _: &amp;Self::A, _: &amp;Self::B) -&gt; bool;
}

impl Contains for Point {
    // Specify types during implementation
    type A = i32;
    type B = i32;

    fn contains(&amp;self, num1: &amp;Self::A, num2: &amp;Self::B) -&gt; bool {
        (&amp;self.x == num1) &amp;&amp; (&amp;self.y == num2)
    }
    // This would also be a valid signature:
    //fn contains(&amp;self, num1: &amp;i32, num2: &amp;i32) -&gt; bool {}
}

fn main() {
    let num1 = 2;
    let num2 = 3;

    let points = vec![Point{x: 1, y: 2}, Point{x: 2, y: 3}];

    for point in points {
        match point.contains(&amp;num1, &amp;num2) {
            true =&gt; println!(&quot;Does contain point!&quot;),
            false =&gt; println!(&quot;Does NOT contain point!&quot;),
        }
    }
}
</code></pre>

            
                <!-- Topic header -->
                <h4 id="traits-conditional-method-implementation">&bull; Conditional Method Implementation</h4>
                <!-- Include topic -->
                <p>You can use traits to conditionally implement methods to a generic struct. Example:</p>

<pre class="rounded"><code class="rust">use std::fmt::Display;

struct Pair&lt;T&gt; {
    x: T,
    y: T,
}

impl&lt;T&gt; Pair&lt;T&gt; {
    fn new(x: T, y: T) -&gt; Self {
        Self {x, y}  // Notice Self vs self
    }
}

impl&lt;T: Display&gt; Pair&lt;T&gt; {
    fn print(&amp;self) {
        println!(&quot;{}, {}&quot;, self.x, self.y);
    }
}

fn main() {
    let p = Pair::new(5, 4);
    p.print();
}
</code></pre>

<h6>Self</h6>
<p>In the above example, you might notice the capital 'S' in <code>Self</code>. Capital <code>Self</code> can be used to refer to the type that is being implemented as opposed to <code>self</code> which refers to the calling object.</p>

            
                <!-- Topic header -->
                <h4 id="traits-default-generic-type">&bull; Default Generic Type</h4>
                <!-- Include topic -->
                <p>A default generic type can be given for traits.</p>

<p>There are two main purposes for this:</p>
<ul>
    <li>Extend a type without breaking existing code</li>
    <li>Customize specific cases</li>
</ul>

<pre><code class="rust">use std::ops::Add;

struct Feet(f32);
struct Inches(f32);

/* // Add trait definition
trait Add&lt;Rhs=Self&gt; {
    type Output;

    fn add(self, rhs: Rhs) -&gt; Self::Output;
}
*/

// Use default
impl Add for Feet {
    type Output = Feet;

    fn add(self, other: Feet) -&gt; Feet {
        Feet(self.0 + other.0)
    }
}

impl Add&lt;Inches&gt; for Feet {
    type Output = Feet;

    fn add(self, other: Inches) -&gt; Feet {
        Feet(self.0 + (other.0 / 12.0))
    }
}
</code></pre>

            
                <!-- Topic header -->
                <h4 id="traits-default-implementation">&bull; Default Implementation</h4>
                <!-- Include topic -->
                <p>To have a default implementation for a trait, use a <code>{}</code> block. 

<p>Default implementations can also call other functions.</p>

<p>Example:</p>

<pre class="rounded"><code class="rust">pub trait Shape {
    fn area(&amp;self) -&gt; f32 {
        0.0
    }
}
</code></pre>

            
                <!-- Topic header -->
                <h4 id="traits-drop">&bull; Drop</h4>
                <!-- Include topic -->
                <p>The <a href="https://doc.rust-lang.org/std/ops/trait.Drop.html" target="_blank"><code>drop</code></a> trait is similar to the deconstructor in C++. When a variable that has resources on the heap, it needs to implement the <code>drop</code> trait so when the variable leaves its scope, the resources are deallocated. If the <code>drop</code> trait in implemented, the <code>copy</code> trait cannot be.</p>

            
                <!-- Topic header -->
                <h4 id="traits-supertraits">&bull; Supertraits</h4>
                <!-- Include topic -->
                <p>Supertraits allow a trait to require the implementation of another trait. Example:</p>

<pre><code class="rust">use std::ops::Add;

#[derive(Debug, PartialEq, Copy, Clone)]
struct Point{ x: i32, y: i32 }

impl Add for Point {
    type Output = Point;

    fn add(self, other: Point) -&gt; Point {
        Point { x: self.x + other.x, y: self.y + other.y }
    }
}

// Supertrait - Has ':' with trait requirements
trait Print: std::fmt::Debug {
    fn print(&amp;self) {
        println!(&quot;*** {:?} *** &quot;, self);
    }
}

impl Print for Point {}

fn main() {
    let p1 = Point{x: 1, y: 2};
    p1.print();
}
</code></pre>

            
                <!-- Topic header -->
                <h4 id="traits-traits-as-parameters">&bull; Traits As Parameters</h4>
                <!-- Include topic -->
                <p>Traits can also be parameters. These functions are similar to generics, but restrict the types to types that implement the trait. Example:</p>

<pre class="rounded"><code class="rust">pub trait Shape {
    fn area(&amp;self) -&gt; f32;
}

pub trait TwoD {}

pub struct Circle {
    radius: f32,
}

impl Shape for Circle {
    fn area(&amp;self) -&gt; f32 {
        self.radius * 3.14159
    }
}

impl TwoD for Circle {}

// Traits as parameters - short hand
pub fn print_area(s: &amp;impl Shape) {
    println!(&quot;{}&quot;, s.area());
}

// Traits as parameters - the long way
pub fn print_area2&lt;T: Shape&gt;(s: &amp;T) {
    println!(&quot;{}&quot;, s.area());
}

// Multiple Traits
pub fn print_area3&lt;T: Shape + TwoD&gt;(s: &amp;T) {
    println!(&quot;{}&quot;, s.area());
}

// where can be used to make trait bounds look pretty
pub fn print_areas&lt;T, U&gt;(s: &amp;T, r: &amp;U) 
    where T: Shape + TwoD,
          U: Shape
{
    println!(&quot;{}&quot;, s.area());
    println!(&quot;{}&quot;, r.area());
}

// Return type that implements trait
pub fn get_area(s: &amp;str) -&gt; impl Shape {
    if s == &quot;Circle&quot; {
        return Circle { radius: 0.0 };
    }
    Circle { radius: 0.0 }  // Imagine other Shapes being here
}

fn main() {
    let cir = Circle { radius: 12.25 };
    print_area3(&amp;cir);
    print_areas(&amp;cir, &amp;cir);
}
</code></pre>

            
        
            <!-- Subject header -->
            <h2 id="types">
                <a href="/learn/rust/types">Types</a>
            </h2>
            
            <!-- For each topic -->
            
                <!-- Topic header -->
                <h4 id="types-compound-types">&bull; Compound Types</h4>
                <!-- Include topic -->
                <p>Compound types combine multiple values into a single type. Rust has two primitive compound types: tuples and arrays.</p>

<h6 style="text-align:center">The Tuple Type</h6>
<p>Tuples have a fixed length and can contain different types.</p>
<pre class="rounded"><code class="rust">fn main() {
    let tup = (10, 1_234, 5678, 12.4, true, 'a');
    let tup : (i32, i32, i32, f64, bool, char) = tup;

    // Destruct tup through pattern matching
    let (a, b, c, d, e, f) = tup;
    println!("{}, {}, {}, {}, {}, {}", a, b, c, d, e, f);

    // Destruct tup through indexing
    let ten = tup.0;
    let c = tup.5;
    println!("{}, {}", ten, c);

    // Return multiple values using a tuple
    let s1 = String::from("Daltie");
    let (s2, len) = find_length(s1);
    println!("The length of '{}' is {}.", s2, len);
}

// Multiple values can be returned from a function using tuples
fn find_length(s: String) -&gt; (String, usize) {
    let length = s.len();
    (s, length)
}</code></pre>



<h6 style="text-align:center">The Array Type</h6>
<p>Arrays are of FIXED length and all elements must be of the same type. See vector in the standard library for a variable length container.</p>
<p>Array data is allocated on the stack rather than the heap (speedy!).</p>
<pre class="rounded"><code class="rust">fn main() {
    // Array Declaration
    let a = [-1, 2, 3, 4, 5];
    let a: [i32; 5] = [1, 2, 3, 4, 5]; // i32 is the type, 5 is the length
    let a = [3; 5]; // [3, 3, 3, 3, 3]

    // Indexing
    let first = a[0];
    let second = a[1];

    // Out of Bounds Runtime error
    let will_panic = a[12]; // Rust will panic and crash instead of trying to access invalid memory
}</code></pre>

            
                <!-- Topic header -->
                <h4 id="types-never-type">&bull; Never Type</h4>
                <!-- Include topic -->
                <p>If a function will never return use the never return type <code>!</code>.</p>

<pre><code class="rust">fn foo() -&gt; ! {}</code></pre>

<p>Some things that return the never type are <code>continue</code> and <code>panic!</code>.</p>

            
                <!-- Topic header -->
                <h4 id="types-scalar-types">&bull; Scalar Types</h4>
                <!-- Include topic -->
                <p>Rust has four primary scalar types:</p>
<ul>
    <li>Integers</li>
    <li>Floating-Point Numbers</li>
    <li>Booleans</li>
    <li>Characters</li>
</ul>

<h6 style="text-align:center">Integer Types</h6>
<table class="table">
    <caption>Integer Types</caption>
    <thead>
        <tr>
            <th scope="col">Length</th>
            <th scope="col">Signed</th>
            <th scope="col">Unsigned</th>
        </tr>
    </thead>
    <tbody>
        <tr> <td>8-bit</td> <td><code>i8</code></td> <td><code>u8</code></td></tr>
        <tr> <td>16-bit</td> <td><code>i16</code></td> <td><code>u16</code></td></tr>
        <tr> <td>32-bit</td> <td><code>i32</code></td> <td><code>u32</code></td></tr>
        <tr> <td>64-bit</td> <td><code>i64</code></td> <td><code>u64</code></td></tr>
        <tr> <td>128-bit</td> <td><code>i128</code></td> <td><code>u128</code></td></tr>
        <tr> <td>arch*</td> <td><code>isize</code></td> <td><code>usize</code></td></tr>
    </tbody>
</table>
<p>The "arch" length is system architecture dependent.</p>

<table class="table">
    <caption>Integer Literals</caption>
    <thead>
        <tr>
            <th scope="col">Number Literals</th>
            <th scope="col">Example</th>
        </tr>
    </thead>
    <tbody>
        <tr><td>Decimal</td><td><code>12_345_678</code></td></tr>
        <tr><td>Hex</td><td><code>0xfe</code></td></tr>
        <tr><td>Octal</td><td><code>0o76</code></td></tr>
        <tr><td>Binary</td><td><code>0b1111_0000</code></td></tr>
        <tr><td>Byte (<code>u8</code> only)</td><td><code>b'A'</code></td></tr>
    </tbody>
</table>

<h6 style="text-align:center">Floating-Point Types</h6>
<table class="table">
    <caption>Floating-Point Types</caption>
    <thead>
        <tr>
            <th scope="col">Length</th>
            <th scope="col">Type</th>
        </tr>
    </thead>
    <tbody>
        <tr><td>32-bit</td><td><code>f32</code></td></tr>
        <tr><td>64-bit</td><td><code>f64</code></td></tr>
    </tbody>
</table>
<p>Note: Rust defaults all floats to <code>f64</code>.</p>


<h6 style="text-align:center">The Boolean Type</h6>
<p>A boolean in Rust is either <code>true</code> or <code>false</code> and takes up one byte. The type is specified with <code>bool</code>.</p>


<h6 style="text-align:center">The Character Type</h6>
<p>The character type in Rust is a four byte Unicode Scalar Value. For example:</p>
<pre class="rounded"><code class="rust">fn main() {
    let c = 'z';
    let z = '';
    let laughing_crying_face = '&#128514;';
}</code></pre>

            
                <!-- Topic header -->
                <h4 id="types-slice">&bull; Slice</h4>
                <!-- Include topic -->
                <p>A slice is a contiguous sequence of elements in a collection. The advantages of slices is they allow you to <i>borrow</i> part of a collection, such as a String or array. This is safe borrowing, if part of the original data is altered, the borrowed data is no longer valid.</p>

<h6>String Slice</h6>
<pre class="rounded"><code class="rust">fn main() {
    let mut name = String::from("Daltie Cole");

    let f_name = first_name(&name[..]); // Let first_name() borrow name. Pass as a string literal

    //name.clear(); // Clear out the name

    // If name was cleared, this line would not compile
    println!("First name: {}", f_name);

    // Other slicing fun
    let daltie = &name[..7];
    let cole = &name[8..];
    let full_name = &name[..];
}

// By using &str as the parameter type instead of &String, string literals can be passed as well
fn first_name(name: &str) -&gt; &str {
    // Convert name into an array of bytes
    let bytes = name.as_bytes();

    // .iter() creates an iterator over the array
    // .enumerate() wraps iter() into a series of tuples where
    //   the first element is the index and the second is the item
    for (i, &item) in bytes.iter().enumerate() {
        // If the element is a binary space
        if item == b' ' {
            // Return the slice from the beginning to the current point
            return &name[0..i];
        }
    }

    &name[..]
}</code></pre>

            
                <!-- Topic header -->
                <h4 id="types-strings">&bull; Strings</h4>
                <!-- Include topic -->
                <h6>Contains</h6>
<p>Returns true if a string contains a substring:</p>
<pre><code class="rust">if s.contains("apple") {}</code></pre>

<h6>Lines</h6>
<p>Iterate though each line in a string:</p>
<pre><code class="rust">for line in s.lines() {}</code></pre>

<h6>Lowercase</h6>
<p>Creates a new string containing the lowercase letters of the old string:</p>
<pre><code class="rust">s.to_lowercase();</code></pre>

<h6>Binary Strings</h6>
<p>Use <code>b""</code> to create a binary string.</p>

            
                <!-- Topic header -->
                <h4 id="types-type">&bull; Type</h4>
                <!-- Include topic -->
                <p>The <code>type</code> keyword is similar to <code>typedef</code> in C++, a type becomes aliased as another type.</p>

<pre><code class="rust">// Simple Example
type Meters = i32;
let x: i32 = 2;
let y: Meters = 5;
let z = x + y;

// Can be used with templates
type Result&gt;T&lt; = std::result::Result&gt;T, std::io::Error&lt;
</code></pre>

            
        
            <!-- Subject header -->
            <h2 id="unsafe">
                <a href="/learn/rust/unsafe">Unsafe</a>
            </h2>
            <p>The <code>unsafe</code> keyword allows you to create a block of code where some of Rust's safety guarantees are no longer applied. This is sometimes necessary when Rust is being to conservative.</p>

<p>Use cases:</p>

<ul>
    <li>Dereference a raw pointer</li>
    <li>Call and unsafe function or method</li>
    <li>Access or modify a mutable static variable</li>
    <li>Implement an unsafe trait</li>
    <li>Access fields of <a href="https://doc.rust-lang.org/reference/items/unions.html" target="_blank"><code>union</code>s</li></a>
</ul>

<p>It is the programmer's responsibility to make sure the code in a <code>unsafe</code> block is safe.</p>

            <!-- For each topic -->
            
                <!-- Topic header -->
                <h4 id="unsafe-functions">&bull; Functions</h4>
                <!-- Include topic -->
                <pre><code class="rust">unsafe fn unsafe_func() {} // Call unsafe inside of here, user beware! Read the docs!

fn abstraction() {} // Unsafe is inside this function, but we are smarter than 
// the compiler (maybe) so we know that the contents of the function are fine

// All functions called from a different programming language are unsafe
extern &quot;C&quot; {
    fn abs(input: i32) -&gt; i32;
}

fn main() {
    unsafe {
        unsafe_func();
    }

    abstraction();

    unsafe {
        println!(&quot;Abs(-12) = {}&quot;, abs(-12));
    }
}
</code></pre>

            
                <!-- Topic header -->
                <h4 id="unsafe-raw-pointers">&bull; Raw Pointers</h4>
                <!-- Include topic -->
                <p>Unsafe rust has two raw pointer types:</p>
<ul>
    <li><code>*const T</code></li>
    <li><code>*mut T</code></li>
</ul>

<p>Raw pointers:</p>
<ul>
    <li>Ignore borrowing rules</li>
    <li>Do not guarantee the pointed to memory is valid</li>
    <li>Can be null</li>
    <li>No automatic clean-up</li>
</ul>

<pre><code class="rust">fn main() {
    let mut num = 4;

    // Raw pointers can be created in safe mode
    let rp1 = &amp;num as *const i32; // *const i32 is the type
    let rp2 = &amp;mut num as *mut i32; // *mut i32 is the type

    // Deallocating raw pointers can only be done in unsafe mode
    unsafe {
        //*rp1 = 10; // Does not work because *const
        println!(&quot;*rp1 = {}&quot;, *rp1);
        *rp2 = 12;
        println!(&quot;*rp2 = {}&quot;, *rp2);
    }
}
</code></pre>

            
                <!-- Topic header -->
                <h4 id="unsafe-static-variables">&bull; Static Variables</h4>
                <!-- Include topic -->
                <p>Rust static variables are called <i>global variables</i> in other languages.</p>

<pre><code class="rust">static PI: f32 = 3.14159;
static mut COUNTER: u32 = 0;

fn main() {
    // Accessing non-mutable static variables is safe
    println!(&quot;Pi = {}&quot;, PI);

    unsafe {
        // Accessing mutable static variables is unsafe (think threads)
        COUNTER += 1;
    }
}
</code></pre>

            
                <!-- Topic header -->
                <h4 id="unsafe-traits">&bull; Traits</h4>
                <!-- Include topic -->
                <p>Traits are unsafe when at least one of its methods have some invariant that the compiler cannot verify. For example, using structs consisting of raw pointers for multi-threaded purposes. We'd have to mark the <code>Send</code> and <code>Sync</code> traits for our struct as <code>unsafe</code> since Rust cannot verify the struct's safety.</p>

<pre><code class="rust">unsafe trait Apple {}
unsafe impl Apple for i32 {}
</code></pre>

            
        
    </div>
</div>

        </div>
    </div>

    <!-- Footer -->
    <footer class="small text-center text-muted">
        <!-- Social Links -->
		<p>
            <a href="https://github.com/DaltonCole" target="_blank" class="fa fa-github" style="font-size:28px;color:black;"></a>
            &nbsp;&nbsp;&nbsp;&nbsp;
            <a href="https://www.linkedin.com/in/daltoncole1/" target="_blank" class="fa fa-linkedin" style="font-size:28px;color:#2867B2;"></a>
        </p>

        <!-- Copyright -->
        
        <p class="copyright"> Copyright &copy; 2020 
            -2024 
         | Dalton Russell Cole</p>

        <!-- Extra Footer Block -->
        
        
    </footer>
</body>
</html>
